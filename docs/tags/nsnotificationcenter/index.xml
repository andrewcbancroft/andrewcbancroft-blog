<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>NSNotificationCenter on Andrew Bancroft</title>
    <link>https://www.andrewcbancroft.com/tags/nsnotificationcenter/</link>
    <description>Recent content about iOS development with Swift in NSNotificationCenter  from Andrew Bancroft.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 05 Feb 2015 13:00:26 +0000</lastBuildDate>
    
        <atom:link href="https://www.andrewcbancroft.com/tags/nsnotificationcenter/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>NSNotificationCenter vs Delegation – An Analysis</title>
      <link>https://www.andrewcbancroft.com/2015/02/05/nsnotificationcenter-vs-delegation-analysis/</link>
      <pubDate>Thu, 05 Feb 2015 13:00:26 +0000</pubDate>
      
      <guid>https://www.andrewcbancroft.com/2015/02/05/nsnotificationcenter-vs-delegation-analysis/</guid>
      <description>&lt;p&gt;In &lt;a href=&#34;http://www.andrewcbancroft.com/2014/10/08/fundamentals-of-nsnotificationcenter-in-swift/&#34;&gt;Fundamentals of NSNotificationCenter in Swift&lt;/a&gt;, a &lt;a href=&#34;http://www.andrewcbancroft.com/2014/10/08/fundamentals-of-nsnotificationcenter-in-swift/#comment-1762533966&#34;&gt;commenter asked&lt;/a&gt; me to elaborate on a response I&amp;rsquo;d given to a dialog going on below the blog post. I had stated:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you need a more structured environment around your [instance]-to-[instance] communication, delegates … are probably a better choice [than NSNotificationCenter].&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I&amp;rsquo;ve been thinking for some time since I responded with that comment. What &lt;em&gt;do&lt;/em&gt; I mean when I say &amp;ldquo;if you need a more structured environment”… What does that even look like? Why are delegates a better choice when I need such &amp;ldquo;structure”?&lt;/p&gt;
&lt;h3 id=&#34;structured-environment-whats-that&#34;&gt;Structured environment? What&amp;rsquo;s that?&lt;/h3&gt;
&lt;p&gt;&amp;ldquo;Structured environment” may be a bit vague. Here&amp;rsquo;s what I was thinking when I wrote it: At the time of the comment, I was imagining what a solution implemented with NSNotificationCenter, and a solution implemented with a delegate look like….&lt;/p&gt;
&lt;h3 id=&#34;questions&#34;&gt;Questions&lt;/h3&gt;
&lt;p&gt;First, I tried to step into the role of each instance, and in a role-playing sort of way, ask:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As a &lt;strong&gt;notifier&lt;/strong&gt; / &lt;strong&gt;delegator&lt;/strong&gt; instance: &amp;ldquo;What do I expect to happen as I send this notification or invoke this method on my delegate? What clues from my execution context inform that expectation?”&lt;/li&gt;
&lt;li&gt;As a &lt;strong&gt;notifier&lt;/strong&gt; / &lt;strong&gt;delegator&lt;/strong&gt; instance: &amp;ldquo;What control do I appear to have over the sequence of events that happen as a result of sending this notification or invoking this method on my delegate?”&lt;/li&gt;
&lt;li&gt;As a &lt;strong&gt;listener&lt;/strong&gt; / &lt;strong&gt;delegate&lt;/strong&gt; instance: &amp;ldquo;What impact does acting on this notification or executing this delegate method have on the system as a whole?”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And then shifting out of the role-playing mentality, stepping back and asking a question of clarity:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Which strategy seems to provide greater clarity and structure to the &lt;em&gt;entire application environment&lt;/em&gt;?”&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Which strategy would most help another developer who might see this code and try to trace the logic and impact of the code?”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The measurement of a more or less &amp;ldquo;structured environment”, then, would be influenced by the answers to the questions of &lt;strong&gt;expectations&lt;/strong&gt;, &lt;strong&gt;perceived control&lt;/strong&gt;, &lt;strong&gt;impact&lt;/strong&gt;, and &lt;strong&gt;clarity&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s explore some of those answers from the perspective of each communication strategy, starting with NSNotificationCenter.&lt;/p&gt;
&lt;h3 id=&#34;answers-from-the-nsnotificationcenter-perspective&#34;&gt;Answers from the NSNotificationCenter Perspective&lt;/h3&gt;
&lt;p&gt;With NSNotificationCenter as an instance-to-instance communication strategy, we have the following environment:&lt;br&gt;
&lt;a href=&#34;http://www.andrewcbancroft.com/wp-content/uploads/2015/02/Notification_Center_Environment.png&#34;&gt;&lt;img src=&#34;http://www.andrewcbancroft.com/wp-content/uploads/2015/02/Notification_Center_Environment.png&#34; alt=&#34;Notification Center Environment&#34; width=&#34;945&#34; height=&#34;374&#34; class=&#34;alignnone size-full wp-image-11252&#34; srcset=&#34;https://www.andrewcbancroft.com/wp-content/uploads/2015/02/Notification_Center_Environment.png 945w, https://www.andrewcbancroft.com/wp-content/uploads/2015/02/Notification_Center_Environment-300x119.png 300w&#34; sizes=&#34;(max-width: 945px) 100vw, 945px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Note that Listeners 1 to n may or may not exist. The graphic is assuming that 1+ Listener instances have &amp;ldquo;tuned in” to a particular notification key.&lt;/p&gt;
&lt;h5 id=&#34;expectations&#34;&gt;Expectations&lt;/h5&gt;
&lt;p&gt;What do I expect to happen? Well, the most reasonable thing I (as a &amp;ldquo;notifier instance”) can expect is for some other &amp;ldquo;listener instance” somewhere to tune in to the notification key I&amp;rsquo;m broadcasting. I have no way of knowing what would happen after that. It&amp;rsquo;s up to the listener to do something intelligent with the notification that [x event] occurred. I, as a notifier, can expect nothing more.&lt;/p&gt;
&lt;h5 id=&#34;perceived-control&#34;&gt;Perceived Control&lt;/h5&gt;
&lt;p&gt;It appears that I, as a notifier, have no control over the sequence of events that would occur as a result of my broadcast. That&amp;rsquo;s by design – the interaction between me and any listener is weak at best.&lt;/p&gt;
&lt;p&gt;This can be a fantastic thing! There&amp;rsquo;s freedom in saying &amp;ldquo;Hey! This happened!” and then being done. But it&amp;rsquo;s also &amp;ldquo;less structured”, as I&amp;rsquo;m terming it.&lt;/p&gt;
&lt;h5 id=&#34;impact&#34;&gt;Impact&lt;/h5&gt;
&lt;p&gt;The impact on the system as a whole has the potential to be significant. With NSNotificationCenter, it depends on how many listener instances there are and what each of them does in response to the notification. One could design the system to localize the impacts to the context of the listening instance. I&amp;rsquo;ve heard of and seen ugly situations that trigger cascading effects that make deciphering the impact of a notification much harder.&lt;/p&gt;
&lt;h5 id=&#34;clarity&#34;&gt;Clarity&lt;/h5&gt;
&lt;p&gt;We lose a good deal of clarity when heavy usage of NSNotificationCenter occurs in an application. There may be appropriate times to use NSNotificationCenter in your app. Keep in mind that it becomes much more difficult to sort out various interactions when more and more listener instances are responding a notification. Trying to reason about how the system as a whole arrived at its current state isn&amp;rsquo;t as easy when NSNotificationCenter enters the picture. Other developers with less knowledge of the app as a whole would suffer from this loss of clarity.&lt;/p&gt;
&lt;h3 id=&#34;answers-from-the-delegate-perspective&#34;&gt;Answers from the Delegate Perspective&lt;/h3&gt;
&lt;p&gt;With a delegate, we have a significantly different strategy at hand. To put it before us:&lt;br&gt;
&lt;a href=&#34;http://www.andrewcbancroft.com/wp-content/uploads/2015/02/Delegate_Environment.png&#34;&gt;&lt;img src=&#34;http://www.andrewcbancroft.com/wp-content/uploads/2015/02/Delegate_Environment.png&#34; alt=&#34;Delegate Environment&#34; width=&#34;948&#34; height=&#34;497&#34; class=&#34;alignnone size-full wp-image-11251&#34; srcset=&#34;https://www.andrewcbancroft.com/wp-content/uploads/2015/02/Delegate_Environment.png 948w, https://www.andrewcbancroft.com/wp-content/uploads/2015/02/Delegate_Environment-300x157.png 300w&#34; sizes=&#34;(max-width: 948px) 100vw, 948px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&#34;expectations-1&#34;&gt;Expectations&lt;/h5&gt;
&lt;p&gt;The delegation strategy deals with protocols. Protocols by nature give us reliable a way to…&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Count on the implementation of needed/expected behavior, and&lt;/li&gt;
&lt;li&gt;Predict what the behavior of the adopter of that protocol will be. By practicing good naming conventions, I, as a delegator, find it reasonable to expect that invoking a method on my delegate will do whatever the name of that method implies.&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;perceived-control-1&#34;&gt;Perceived Control&lt;/h5&gt;
&lt;p&gt;It would appear that as a delegator, I can control the sequence of events that need to take place by choosing when to invoke methods on my delegate. A strategy using NSNotificationCenter can only send out a notification into the ether, and hope that something acts on it. A strategy using delegation has a &lt;em&gt;delegate&lt;/em&gt; which adopts a protocol. Every method is at my disposal to call in whatever order makes sense.&lt;/p&gt;
&lt;h5 id=&#34;impact-1&#34;&gt;Impact&lt;/h5&gt;
&lt;p&gt;The impact on the system as a whole still has the potential to be significant. Since there&amp;rsquo;s one-to-one communication going on between a delegator and its delegate, the determining factor on how broad the impact is tends to lean on the design of the system as a whole. Design patterns that minimize or eliminate global state reduce this potentially broad impact.&lt;/p&gt;
&lt;p&gt;One advantage that the delegation pattern has is that the delegate conforms to a protocol and a protocol, along with its specified methods, have &lt;em&gt;names&lt;/em&gt;. However small that knowledge is, it could give us clues about what impact of executing the delegate&amp;rsquo;s methods might have on the system.&lt;/p&gt;
&lt;h5 id=&#34;clarity-1&#34;&gt;Clarity&lt;/h5&gt;
&lt;p&gt;With the advantage of dealing with intelligently named protocols and clearly outlined method names, the delegation strategy would win the battle of clarity in my opinion. I can look at the delegator instance and say, &amp;ldquo;When execution of this instance&amp;rsquo;s logic gets to this point, reliance on the delegate kicks in and [x, y, and z] happens. I can jump over to the delegate&amp;rsquo;s implementation and say, &amp;ldquo;[x] does this, [y] does that, and [z] does this other thing.” Other developers with less knowledge of the app as a whole would enjoy this added clarity quite readily.&lt;/p&gt;
&lt;h3 id=&#34;in-summary&#34;&gt;In Summary&lt;/h3&gt;
&lt;p&gt;Here, I&amp;rsquo;ve analyzed NSNotificationCenter, side by side with the delegation pattern, by imagining myself in the role of each instance (notifier, listener | delegator, delegate). I assessed each strategy in terms of expectations, perceived control, impact, and clarity, attempting to shed light on what it means for an environment to be &amp;ldquo;more structured” or &amp;ldquo;less structured”. My hope was to shed light on my use of the term &amp;ldquo;structured environment”, and to share my thoughts on some of the implications of using each strategy.&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;related&#34; class=&#34;jump-target&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;resources&#34;&gt;
  &lt;div class=&#34;resources-header&#34;&gt;
    You might also enjoy&amp;#8230;
  &lt;/div&gt;
  &lt;ul class=&#34;resources-content&#34;&gt;
    &lt;li&gt;
      &lt;i class=&#34;fa fa-angle-right&#34;&gt;&lt;/i&gt; &lt;a href=&#34;http://www.andrewcbancroft.com/2015/03/26/what-is-delegation-a-swift-developers-guide/&#34; title=&#34;What is Delegation? – A Swift Developer’s Guide&#34;&gt;What is Delegation? – A Swift Developer’s Guide&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;i class=&#34;fa fa-angle-right&#34;&gt;&lt;/i&gt; &lt;a href=&#34;http://www.andrewcbancroft.com/2015/04/08/how-delegation-works-a-swift-developer-guide/&#34; title=&#34;How Delegation Works – A Swift Developer’s Guide&#34;&gt;How Delegation Works – A Swift Developer’s Guide&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;i class=&#34;fa fa-angle-right&#34;&gt;&lt;/i&gt; &lt;a href=&#34;http://www.andrewcbancroft.com/2014/10/08/fundamentals-of-nsnotificationcenter-in-swift/&#34; title=&#34;Fundamentals of NSNotificationCenter in Swift&#34;&gt;Fundamentals of NSNotificationCenter in Swift&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;i class=&#34;fa fa-angle-right&#34;&gt;&lt;/i&gt; &lt;a href=&#34;https://www.andrewcbancroft.com/2016/02/15/fundamentals-of-callbacks-for-swift-developers/&#34; title=&#34;Fundamentals of Callbacks for Swift Developers&#34;&gt;Fundamentals of Callbacks for Swift Developers&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a name=&#34;share&#34; class=&#34;jump-target&#34;&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fundamentals of NSNotificationCenter in Swift</title>
      <link>https://www.andrewcbancroft.com/2014/10/08/fundamentals-of-nsnotificationcenter-in-swift/</link>
      <pubDate>Wed, 08 Oct 2014 18:27:47 +0000</pubDate>
      
      <guid>https://www.andrewcbancroft.com/2014/10/08/fundamentals-of-nsnotificationcenter-in-swift/</guid>
      <description>&lt;p&gt;&lt;small&gt;Updated on September 19, 2016 – Xcode 8 &amp;amp; Swift 3.0&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;The goal of this post is to help you grasp the fundamentals of using &lt;code&gt;NSNotificationCenter&lt;/code&gt; in your Swift iOS app. The topic isn&amp;rsquo;t necessarily new, and there&amp;rsquo;s no difference except syntax between Objective-C and Swift implementations involving &lt;code&gt;NSNotificationCenter&lt;/code&gt;. Even still, I&amp;rsquo;m hoping to add to the understanding of this useful tool by giving a fully-working example on GitHub (&lt;a title=&#34;GitHub - Swift NSNotificationCenter Example&#34; href=&#34;https://github.com/andrewcbancroft/SwiftNSNotificationCenter/tree/swift-2.3&#34; target=&#34;_blank&#34;&gt;Swift 2.3&lt;/a&gt; and &lt;a title=&#34;GitHub - Swift NSNotificationCenter Example&#34; href=&#34;https://github.com/andrewcbancroft/SwiftNSNotificationCenter&#34; target=&#34;_blank&#34;&gt;Swift 3.0&lt;/a&gt;), and by sharing the insight that&amp;rsquo;s clicked in my own brain as I explain the example.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Code in the main article below is written in Swift 3.0, but code examples for Swift 2.3 are found in the &lt;a href=&#34;https://github.com/andrewcbancroft/SwiftNSNotificationCenter/tree/swift-2.3&#34;&gt;example project&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;what-is-it&#34; class=&#34;jump-target&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;first-things-first-what-_is_-this-thing&#34;&gt;First things first: What &lt;em&gt;is&lt;/em&gt; this thing?&lt;/h3&gt;
&lt;p&gt;When I first heard &lt;code&gt;NSNotificationCenter&lt;/code&gt;, I thought &amp;ldquo;push notifications”. However, &lt;code&gt;NSNotificationCenter&lt;/code&gt; has nothing to do with sending or receiving push notifications in iOS. Rather, it is a communication tool internal to your app. It provides a way for one instance of a class/struct to notify one or more &lt;em&gt;other&lt;/em&gt; class/struct instances about something. The goal in doing this is to enable those 1+ other class or struct instances to take appropriate action based the communication they receive. An common analogy comes to mind: think &amp;ldquo;radio tower”. &lt;code&gt;NSNotificationCenter&lt;/code&gt; is the central hub that acts as a &lt;em&gt;broadcaster&lt;/em&gt; of notifications. If that still seems vague, hang tight – seeing the example below should help it all come together for you.&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;should-i-use-it&#34; class=&#34;jump-target&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;should-i-use-it&#34;&gt;Should I use it?&lt;/h3&gt;
&lt;p&gt;Before diving into the basic workflow, it&amp;rsquo;s worth asking, &amp;ldquo;Should I use &lt;code&gt;NSNotificationCenter&lt;/code&gt;, or is there some other option that&amp;rsquo;s more appropriate for my app&amp;rsquo;s internal communication needs?”&lt;/p&gt;
&lt;p&gt;It is often the case that there is more than one way to solve a problem in software development, and it&amp;rsquo;s no different with &lt;code&gt;NSNotificationCenter&lt;/code&gt;. There is more than one way to accomplish instance-to-instance communication at run-time. I&amp;rsquo;ve written about two such forms of communication in my post titled &lt;a href=&#34;https://www.andrewcbancroft.com/2015/02/05/nsnotificationcenter-vs-delegation-analysis/&#34;&gt;NSNotificationCenter vs Delegation – An Analysis&lt;/a&gt;. It may be worth reading up on, just to make sure you&amp;rsquo;re using the right tool for the right kind of communication.&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;basic-workflow&#34; class=&#34;jump-target&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;basic-workflow&#34;&gt;Basic Workflow&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;NSNotificationCenter.default&lt;/code&gt; is at the center of it all when it comes to this discussion.&lt;/p&gt;
&lt;p&gt;The basic workflow of using &lt;code&gt;NSNotificationCenter&lt;/code&gt; goes something like this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Since `NSNotificationCenter` is in the business of broadcasting notifications, the first thing to do is to specify a way to uniquely identify a notification. This is most easily accomplished by defining a constant string value (using `let` syntax in Swift) at a globally-visible scope. The string constant you define here will serve as a &amp;ldquo;notification key”. If you have several notification keys that you need to define, perhaps creating a new .swift file called &amp;ldquo;NSNotificationCenterKeys.swift” is a clean way to do this.&lt;/li&gt;
&lt;li&gt;Steps 2 and 3 of the workflow go hand-in-hand. Without implementing the one, implementing the other doesn&amp;rsquo;t make much sense… Step 2 is to &lt;em&gt;post&lt;/em&gt; a notification to `NSNotificationCenter.default` identified by the key that was created in step 1. In radio terms, the class or struct instance desiring to post a notification asks the default notification center to broadcast the notification key defined in step 1… this class or struct instance chooses the right situations to request that the notification key be sent out based on business logic specific to the project&amp;rsquo;s requirements.&lt;/li&gt;
&lt;li&gt;Step 3 is to set up 1+ class or struct instances to be &lt;em&gt;listeners&lt;/em&gt;, or more properly, &lt;em&gt;observers&lt;/em&gt; of a particular notification. Such an observer will be able to tell that it&amp;rsquo;s &amp;ldquo;heard” the notification, because it will be &amp;ldquo;listening for” a notification that uses the same key that was created in step 1, which is the key used in step 2 to &lt;em&gt;post&lt;/em&gt; the notification. In radio terms, the listener is tuned in to the default notification center&amp;rsquo;s station that&amp;rsquo;s identified by that special key defined in step 1 and posted in step 2. So you see now why steps 2 and 3 go hand-in-hand. With no posts to the notification center on that station, tuning in will do no good. Likewise, posting a notification but having no listeners accomplishes nothing.&lt;/li&gt;
&lt;li&gt;Finally, what should the observing instance &lt;em&gt;do&lt;/em&gt; once it&amp;rsquo;s detected the notification? Well, when signing up to be an observer, the instance must also specify the name of a function that will be called upon receipt of the notification it&amp;rsquo;s listening for. Whatever action or routine is appropriate to perform at that time is what that function&amp;rsquo;s implementation should contain.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name=&#34;visualize&#34; class=&#34;jump-target&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;visualizing-nsnotificationcenter-by-example&#34;&gt;Visualizing NSNotificationCenter by Example&lt;/h3&gt;
&lt;p&gt;If you&amp;rsquo;re like me, you need less talk and more example, so I&amp;rsquo;ve created a simple Xcode project that you can grab over at GitHub (&lt;a title=&#34;GitHub - Swift NSNotificationCenter Example&#34; href=&#34;https://github.com/andrewcbancroft/SwiftNSNotificationCenter&#34; target=&#34;_blank&#34;&gt;Swift 2.3&lt;/a&gt; and &lt;a title=&#34;GitHub - Swift NSNotificationCenter Example&#34; href=&#34;https://github.com/andrewcbancroft/SwiftNSNotificationCenter/tree/swift-3.0&#34; target=&#34;_blank&#34;&gt;Swift 3.0&lt;/a&gt;). Running the project will allow you to click through a series of tabs in a tab view controller, post a notification, and see the results. It looks much like this:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.andrewcbancroft.com/wp-content/uploads/2014/10/NSNotificationCenterExample.gif&#34;&gt;&lt;img class=&#34;size-full wp-image-5461 aligncenter&#34; src=&#34;https://www.andrewcbancroft.com/wp-content/uploads/2014/10/NSNotificationCenterExample.gif&#34; alt=&#34;NS Notification Center Example&#34; width=&#34;356&#34; height=&#34;636&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Working back through the basic workflow with this example you can find the following key aspects of implementing a &lt;code&gt;NSNotificationCenter&lt;/code&gt; solution (lines of code to pay special attention to will be highlighted).&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;steps1-2&#34; class=&#34;jump-target&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;steps-1-and-2&#34;&gt;Steps 1 and 2:&lt;/h4&gt;
&lt;p&gt;I&amp;rsquo;ve chosen my &lt;code&gt;FirstViewController&lt;/code&gt; class to be the one that defines the global constant with a unique notification key and tells the default notification center to post that notification when the &amp;ldquo;Notify!” button is tapped:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 1. Globally define a &amp;#34;special notification key&amp;#34; constant that can be broadcast / tuned in to...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;mySpecialNotificationKey&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;com.andrewcbancroft.specialNotificationKey&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;FirstViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UIViewController&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;weak&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;sentNotificationLabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UILabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;override&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kc&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;NotificationCenter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addObserver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;#selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FirstViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;updateNotificationSentLabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NSNotification&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rawValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mySpecialNotificationKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 2. Post notification using &amp;#34;special notification key&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;@IBAction&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;notify&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;NotificationCenter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;post&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Notification&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rawValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mySpecialNotificationKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;17&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;updateNotificationSentLabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kc&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sentNotificationLabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;text&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Notification sent!&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;19&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a name=&#34;steps3-4&#34; class=&#34;jump-target&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;steps-3-and-4&#34;&gt;Steps 3 and 4:&lt;/h4&gt;
&lt;p&gt;Both of these steps are implemented in very similar ways in my &lt;code&gt;SecondViewController&lt;/code&gt; and &lt;code&gt;ThirdViewController&lt;/code&gt; classes. The code should speak for itself:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;SecondViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UIViewController&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;weak&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;notificationLabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UILabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;override&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kc&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 3.  Observe (listen for) &amp;#34;special notification key&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;NotificationCenter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addObserver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;#selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SecondViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actOnSpecialNotification&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NSNotification&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rawValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mySpecialNotificationKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 4.  Implement function to act on that notification&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// The name of this function must match the selector argument you specified when you called addObserver()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;actOnSpecialNotification&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kc&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;notificationLabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;text&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;I heard the notification!&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;17&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;19&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ThirdViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UIViewController&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;weak&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;notificationLabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UILabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;21&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;22&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;override&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;23&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kc&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;24&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;NotificationCenter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addObserver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;#selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ThirdViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actOnSpecialNotification&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NSNotification&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rawValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mySpecialNotificationKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;26&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;27&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;actOnSpecialNotification&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;28&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kc&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;notificationLabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;text&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;I heard the notification, too!&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;29&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, to reiterate the explanation in visual form and for easy reference, I&amp;rsquo;ve annotated a screen shot taken from the project&amp;rsquo;s code:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.andrewcbancroft.com/wp-content/uploads/2014/10/NSNotificationCenterExplanation_Swift3.png&#34;&gt;&lt;img src=&#34;https://www.andrewcbancroft.com/wp-content/uploads/2014/10/NSNotificationCenterExplanation_Swift3-1024x825.png&#34; alt=&#34;NSNotificationCenter Explanation&#34; width=&#34;1024&#34; height=&#34;825&#34; class=&#34;alignnone size-large wp-image-13039&#34; srcset=&#34;https://www.andrewcbancroft.com/wp-content/uploads/2014/10/NSNotificationCenterExplanation_Swift3-1024x825.png 1024w, https://www.andrewcbancroft.com/wp-content/uploads/2014/10/NSNotificationCenterExplanation_Swift3-300x242.png 300w, https://www.andrewcbancroft.com/wp-content/uploads/2014/10/NSNotificationCenterExplanation_Swift3.png 1100w&#34; sizes=&#34;(max-width: 1024px) 100vw, 1024px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;remove-observer&#34; class=&#34;jump-target&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;removing-an-observer&#34;&gt;Removing an observer&lt;/h3&gt;
&lt;p&gt;One final requirement for working with &lt;code&gt;NSNotificationCenter&lt;/code&gt; is to remove an observer when it no longer needs to listen for notifications. When might this situation arise?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When the observer is no longer referenced and thus deallocated from memory, it should tell the default notification center that it can be removed&lt;/li&gt;
&lt;li&gt;When some condition occurs in your application that renders it no longer relevant for an instance to listen for notifications&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first situation is the most common, and is for sure the scenario that we want to protect against, so that the default notification center doesn&amp;rsquo;t continue to manage observers that are no longer capable of actively listening. To satisfy the requirement of removing an observer when an instance is deallocated, we could provide something like the following &lt;code&gt;deinit&lt;/code&gt; method:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;deinit&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;NSNotificationCenter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;removeObserver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For the second bullet point, you can simply write the same line of code that&amp;rsquo;s highlighted in the above snippet, wherever it makes sense for you to tell the default notification center when it&amp;rsquo;s appropriate to stop sending messages to the instance in question.&lt;/p&gt;
&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;NSNotificationCenter&lt;/code&gt; is particularly useful when there are multiple class or struct instances that need to take action based on something that happens elsewhere in your application. For this type of scenario, &lt;code&gt;NSNotificationCenter&lt;/code&gt; can be a great tool to wield as you develop apps in Swift for iOS.&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;related&#34; class=&#34;jump-target&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;resources&#34;&gt;
  &lt;div class=&#34;resources-header&#34;&gt;
    You might also enjoy&amp;#8230;
  &lt;/div&gt;
  &lt;ul class=&#34;resources-content&#34;&gt;
    &lt;li&gt;
      &lt;i class=&#34;fa fa-angle-right&#34;&gt;&lt;/i&gt; &lt;a href=&#34;https://www.andrewcbancroft.com/2015/02/05/nsnotificationcenter-vs-delegation-analysis/&#34; title=&#34;NSNotificationCenter vs Delegation – An Analysis&#34;&gt;NSNotificationCenter vs Delegation – An Analysis&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a name=&#34;share&#34; class=&#34;jump-target&#34;&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>