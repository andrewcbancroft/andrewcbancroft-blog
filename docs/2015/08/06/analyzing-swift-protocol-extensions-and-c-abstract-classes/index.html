<!DOCTYPE html>
<html lang="en">

<head>

    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-33022655-1"></script>
    <script>
            (function () {
                if (window.location.hostname === "localhost") {
                    console.log("Analytics not running on local dev.");
                    return;
                } else {
                    window.dataLayer = window.dataLayer || [];
                    function gtag() { dataLayer.push(arguments); }
                    gtag('js', new Date());

                    gtag('config', 'UA-33022655-1');
                }
            })();
    </script>

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6356224024630676",
            enable_page_level_ads: true
        });
    </script>

    <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css" />
    <script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js"></script>
    <script>
    window.addEventListener("load", function(){
    window.cookieconsent.initialise({
    "palette": {
        "popup": {
        "background": "#3e8bc5"
        },
        "button": {
        "background": "#8ec760",
        "text": "#ffffff"
        }
    }
    })});
    </script>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Analyzing Swift Protocol Extensions and C# Abstract Classes" />
<meta property="og:description" content="Being a C# developer by day and a Swift developer by night has me constantly thinking about the similarities and differences between these two languages. I genuinely enjoy programming with each, and I love it when I can take a strategy that works well in one language, and see where that might cross over to the other. One of the areas I&rsquo;ve been pondering as of late is the idea of how Swift and C# compare in terms of protocol extensions and abstract classes." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.andrewcbancroft.com/2015/08/06/analyzing-swift-protocol-extensions-and-c-abstract-classes/" />
<meta property="article:published_time" content="2015-08-07T03:52:25&#43;00:00"/>
<meta property="article:modified_time" content="2015-08-07T03:52:25&#43;00:00"/>

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Analyzing Swift Protocol Extensions and C# Abstract Classes"/>
<meta name="twitter:description" content="Being a C# developer by day and a Swift developer by night has me constantly thinking about the similarities and differences between these two languages. I genuinely enjoy programming with each, and I love it when I can take a strategy that works well in one language, and see where that might cross over to the other. One of the areas I&rsquo;ve been pondering as of late is the idea of how Swift and C# compare in terms of protocol extensions and abstract classes."/>
<meta name="generator" content="Hugo 0.55.6" /> 
    
    
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "Analyzing Swift Protocol Extensions and C# Abstract Classes",
  "url": "https:\/\/www.andrewcbancroft.com\/2015\/08\/06\/analyzing-swift-protocol-extensions-and-c-abstract-classes\/",
  "wordCount": "2464",
  "datePublished": "2015-08-07T03:52:25Z",
  "dateModified": "2015-08-07T03:52:25Z",
  "author": {
    "@type": "Person",
    "name": "Andrew"
  },
  "keywords": "C#, Swift, Abstract Class, Protocols"

  ,"description": ""
}
</script>



    <title>Analyzing Swift Protocol Extensions and C# Abstract Classes</title>

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb"
        crossorigin="anonymous">

    
    <link href="https://www.andrewcbancroft.com/css/custom.css" rel="stylesheet"> 
    <link href="https://www.andrewcbancroft.com/css/syntax.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Muli:400,500,700" rel="stylesheet">
        
    <link href="" rel="alternate" type="application/rss+xml" title="Andrew Bancroft" /> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css" integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">
    <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

</head>

<body>

    <nav class="navbar navbar-expand-lg fixed-top px-5">
            <a class="navbar-brand" href="https://www.andrewcbancroft.com"><i class="fas fa-home"></i> Andrew Bancroft</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
                aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="nav navbar-nav mr-auto mt-2 mt-lg-0"></ul>
                <ul class="navbar-nav">
                        <li class="nav-item">
                                <a class="nav-link" href="https://www.andrewcbancroft.com#pluralsight-courses">Pluralsight Courses</a>
                        </li>

                    <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true"
                                aria-expanded="false">
                                Topics
                            </a>
                            <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown">
                                <h6 class="dropdown-header">iOS Development</h6>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#data-persistence">Data Persistence</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#dependency-management">Dependency Management</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#debugging">Debugging</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#eventkit">Event Kit</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#iap">In-App Purchases</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#parse">Parse</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#patterns-and-practices">Patterns and Practices</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#react-native">React Native</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#swift-how-tos">Swift How-To's</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#swift-language-notes">Swift Language Notes</a>
                                
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#testing">Testing</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#ui-work">User Interface Work</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#xcode">Xcode</a>
                                <div class="dropdown-divider"></div>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#dot-net-development">.Net Development</a>
                                <div class="dropdown-divider"></div>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#musings">Musings</a>
                            </div>
                        </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true"
                            aria-expanded="false">
                            Connect With Me
                        </a>
                        <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown">
                            <a class="dropdown-item" href="https://www.pluralsight.com/authors/andrew-bancroft"><i class="fas fa-play"></i> Pluralsight Courses</a>
                            <a class="dropdown-item" href="https://github.com/andrewcbancroft"><i class="fab fa-github"></i> GitHub</a>
                            <a class="dropdown-item" href="https://www.linkedin.com/in/andrewcbancroft/"><i class="fab fa-linkedin"></i> LinkedIn</a>
                            <a class="dropdown-item" href="https://twitter.com/andrewcbancroft"><i class="fab fa-twitter"></i> Twitter</a>
                            <a class="dropdown-item" href="https://www.youtube.com/channel/UCDPV9kMhP-b5EFRI7d812pg"><i class="fab fa-youtube"></i> YouTube</a>
                            <a class="dropdown-item" href="https://dataday.life"><i class="fas fa-link"></i> www.dataday.life</a>
                            <a class="dropdown-item" href="https://www.andrewcbancroft.com/index.xml"><i class="fas fa-rss"></i> Feed</a>
                        </div>
                    </li>
                </ul>
        </div>
    </nav>

    
    
    
    
    
    
    
    

    
    <div class="container">
        <div class="row">
            <div class="col-sm-12">

                


<article>
  <div class="article">
    <header>
      <h1 class="article-title">Analyzing Swift Protocol Extensions and C# Abstract Classes</h1>
    </header>
    <div class="content">

    <p></p>

    

<p>Being a C# developer by day and a Swift developer by night has me constantly thinking about the similarities and differences between these two languages. I genuinely enjoy programming with each, and I love it when I can take a strategy that works well in one language, and see where that might cross over to the other. One of the areas I&rsquo;ve been pondering as of late is the idea of how Swift and C# compare in terms of protocol extensions and abstract classes.</p>

<p>Swift doesn&rsquo;t have the notion of <a href="https://msdn.microsoft.com/en-us/library/sf985hc5.aspx">abstract classes</a> like C# does. However, it <em>does</em> now have an amazingly powerful feature called protocol extensions, which were explained and demonstrated in the popular WWDC15 talk on <a href="https://developer.apple.com/videos/wwdc/2015/?id=408">Protocol Oriented Programming</a>. Why am I comparing protocol extensions with C# abstract classes? What are the similarities? What are the differences? Which one do I like best? The analysis of and concluding answers to these questions is the goal of this article.</p>

<p><a name="why" class="jump-target"></a></p>

<h3 id="why-the-comparison">Why the comparison?</h3>

<p>What got me thinking about this? Well, I was re-watching <a href="https://developer.apple.com/videos/wwdc/2015/?id=408">Protocol Oriented Programming</a> the other day and was digesting some of the arguments for why protocols often serve as better abstractions than classes. When classes are used to model a generalized abstraction, the only way they do it is through inheritance. Subclasses of some other, more generalized, base class will automatically be able to behave the same and store the same state as that base class by virtue of inheritance.</p>

<p>Protocols on the other hand, model abstraction through composable template-like descriptions: &ldquo;Adopters of this protocol will do [x, y, and z] by implementing [function x, function y, and function z] and will have [property a, and property b]&#8221;, etc&#8230; But they define a template only – no implementations are defined within a protocol.</p>

<p>In C#, we have a similar mechanism to protocols called interfaces. The same paradigm of defining a template with no implementations exists in C# when we use an interface to model some abstraction. C#, of course, also has classes and can pass along behavior and state to subclasses through inheritance.</p>

<p><a name="understanding-cs-abstract-classes" class="jump-target"></a></p>

<h4 id="understanding-c-abstract-classes">Understanding C# abstract classes</h4>

<p>But C# has one <em>other</em> mechanism for abstraction: <strong>abstract classes</strong>. These special types of abstractions have the ability to behave like interfaces (or protocols) in that they can strictly define a template with no implementation, requiring all <em>subclasses</em> to supply that implementation. But abstract classes are unique in that they aren&rsquo;t <em>required</em> to define a template <em>only</em> – they can actually provide a default implementation that may or may not be overridden in a subclass, depending on what the implementer of the subclass wants to do.</p>

<p>We still can&rsquo;t make instances of an abstract class, just like we can&rsquo;t make instances of an interface or protocol. But with abstract classes, we can provide some default implementation that can be a customization point for concrete subclasses, should the implementer of the subclass desire to override this default behavior.</p>

<p><a name="back-to-swift" class="jump-target"></a></p>

<h4 id="bringing-it-back-to-swift">Bringing it back to Swift</h4>

<p>So&#8230; what does this have to do with Swift? Well, it seemed to me that there&rsquo;s a <em>little</em> overlap between Swift 2.0&rsquo;s new protocol extensions, and C# abstract classes. How?</p>

<p>With Swift protocol extensions, we can now provide default implementation for a protocol requirement, such that any adopter of the protocol <em>automatically</em> uses that implementation and satisfies that particular requirement of the protocol.</p>

<p>A given Type implementing the extended protocol could choose to provide its own implementation to customize the behavior as it needs. But if it chooses not to, it gets that default behavior for free.</p>

<p>Therein lies the overlap I see between Swift protocol extensions and C# abstractions. But let&rsquo;s explore a little more in terms of similarities and differences between the two by analyzing an example.</p>

<p><a name="example" class="jump-target"></a></p>

<h3 id="working-example-modeling-athletes">Working example: Modeling athletes</h3>

<p>Suppose for a moment that we&rsquo;re working on an app that models athletic competition (such as marathons, triathlons, and other sporting events). Now, athletic competition implies <em>athletes</em>, does it not?</p>

<p>How then, could we model an <code>Athlete</code> in an abstract way? That is, how can we provide just the blueprint for what an <code>Athlete</code> does, so that such a Type can be entered into one of the athletic competitions and perform in it?</p>

<p><a name="model-with-cs" class="jump-target"></a></p>

<h4 id="modeling-the-athlete-abstraction-with-c">Modeling the Athlete abstraction with C#</h4>

<p>In C#, we&rsquo;ve got two possibilities: Create an interface, or create an abstract class.</p>

<p>Using an interface may look something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="ln">1</span><span class="kd">public</span> <span class="n">interface</span> <span class="n">Athlete</span>
<span class="ln">2</span><span class="p">{</span>
<span class="ln">3</span>    <span class="kd">public</span> <span class="n">void</span> <span class="n">Run</span><span class="p">();</span>
<span class="ln">4</span>    <span class="kd">public</span> <span class="n">void</span> <span class="n">Swim</span><span class="p">();</span>
<span class="ln">5</span>    <span class="kd">public</span> <span class="n">void</span> <span class="n">Cycle</span><span class="p">();</span>
<span class="ln">6</span>    <span class="c1">// Other things that an Athlete may be able to do</span>
<span class="ln">7</span><span class="p">}</span></code></pre></div>
<p>Using an abstract class may look very similar. The primary difference is in the declaration of each method, where we mark each of them <code>virtual</code>, so that they can be overridden in a subclass to provide that customization point I talked about earlier:</p>

<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="ln">1</span><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Athlete</span>
<span class="ln">2</span><span class="p">{</span>
<span class="ln">3</span>    <span class="k">public</span> <span class="k">abstract</span> <span class="k">void</span> <span class="n">Run</span><span class="p">();</span>
<span class="ln">4</span>    <span class="k">public</span> <span class="k">abstract</span> <span class="k">void</span> <span class="n">Swim</span><span class="p">();</span>
<span class="ln">5</span>    <span class="k">public</span> <span class="k">abstract</span> <span class="k">void</span> <span class="n">Cycle</span><span class="p">();</span>
<span class="ln">6</span>    <span class="c1">// Other things that an Athlete may be able to do
</span><span class="ln">7</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>Right off, you might be asking, &ldquo;Should a marathon runner have to be able to swim and cycle??&#8221;. It&rsquo;s a great question, and I&rsquo;ll address it further down in the article when I discuss <a href="#refactoring">&ldquo;refactoring for enhanced composability with Swift protocol extensions&#8221;</a>.</p>

<p><a name="model-with-swift" class="jump-target"></a></p>

<h4 id="modeling-the-athlete-abstraction-with-swift">Modeling the Athlete abstraction with Swift</h4>

<p>In Swift, we essentially have one possibility that compares with C# for a pure abstraction, that is, just the blueprint describing an <code>Athlete's</code> capabilities: Create a protocol.</p>

<p>The <code>Athlete</code> protocol might look something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="ln">1</span><span class="kd">protocol</span> <span class="nc">Athlete</span> <span class="p">{</span>
<span class="ln">2</span>    <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span>
<span class="ln">3</span>    <span class="kd">func</span> <span class="nf">swim</span><span class="p">()</span>
<span class="ln">4</span>    <span class="kd">func</span> <span class="nf">cycle</span><span class="p">()</span>
<span class="ln">5</span>    <span class="c1">// Other things that an Athlete may be able to do</span>
<span class="ln">6</span><span class="p">}</span></code></pre></div>
<p>We still don&rsquo;t avoid the necessity of a marathon runner being required to be able to swim and cycle. And having read <a href="http://owensd.io/2015/08/06/protocols.html">David Owens&rsquo; recent recommendations on Protocols</a>, I&rsquo;m even more uncomfortable with modeling an <code>Athlete</code> this way, because it feels like we&rsquo;re treating a protocol as a Type here, which he identifies as a less powerful usage of protocols.</p>

<p>I want to refactor this, but for this moment in time, we&rsquo;ll stick with the code as-is, just to keep it as similar to the C# code as possible. I&rsquo;ll discuss <a href="#refactoring">an option for refactoring this shortly</a>.</p>

<p><a name="default-implementation" class="jump-target"></a></p>

<h4 id="default-implementation-for-athletic-abilities">Default implementation for athletic abilities</h4>

<p>As the example stands right now in both C# and Swift, we&rsquo;ve got a situation where any Type wishing to be an <code>Athlete</code>, whether it be by implementing the C# interface, subclassing the C# abstract class, or adopting the Swift protocol, <em>must</em> provide implementations of each of those athletic abilities (run, swim, and cycle). The Type can&rsquo;t <em>not</em> implement one of those requirements and have the code still compile. They&rsquo;re requirements of what it means to be an <code>Athlete</code>, so the Type must conform.</p>

<p>Suppose that in our scenario, any given <code>Athlete</code> has one <em>primary</em> ability which he/she is amazing at, but when it comes to his/her non-primary abilities, the <code>Athlete</code> is only able to perform at &ldquo;average&#8221; skill.</p>

<p>This sounds like a case where it might be nice to have overridable default implementation provided. Any <em>specific</em> type of <code>Athlete</code> could override that default implementation to perform the ability better or worse, depending on what kind of <code>Athlete</code> he/she is. But if the specific <code>Athlete</code> Type didn&rsquo;t provide an customized override, the Type would get the &ldquo;average&#8221; behavior for free.</p>

<p>How could we make this happen?</p>

<p><a name="default-implementation-with-cs" class="jump-target"></a></p>

<h5 id="default-implementation-with-c">Default implementation with C#</h5>

<p>In C#, abstract classes allow us to do just that. Here&rsquo;s how a default implementation might be written:</p>

<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="ln"> 1</span><span class="p">{</span>
<span class="ln"> 2</span>    <span class="k">public</span> <span class="k">virtual</span> <span class="k">void</span> <span class="n">Run</span><span class="p">()</span>
<span class="ln"> 3</span>    <span class="p">{</span>
<span class="ln"> 4</span>        <span class="c1">// run with average speed and endurance
</span><span class="ln"> 5</span><span class="c1"></span>    <span class="p">}</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span>    <span class="k">public</span> <span class="k">virtual</span> <span class="k">void</span> <span class="n">Swim</span><span class="p">()</span>
<span class="ln"> 8</span>    <span class="p">{</span>
<span class="ln"> 9</span>        <span class="c1">// swim with average speed and endurance
</span><span class="ln">10</span><span class="c1"></span>    <span class="p">}</span>
<span class="ln">11</span>
<span class="ln">12</span>    <span class="k">public</span> <span class="k">virtual</span> <span class="k">void</span> <span class="n">Cycle</span><span class="p">()</span>
<span class="ln">13</span>    <span class="p">{</span>
<span class="ln">14</span>        <span class="c1">// cycle with average speed and endurance
</span><span class="ln">15</span><span class="c1"></span>    <span class="p">}</span>
<span class="ln">16</span><span class="p">}</span>
</code></pre></div>

<p>So now, when we want to model a <code>MarathonRunner</code>, we can override his/her ability to run, swim, and cycle as appropriate:</p>

<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="ln">1</span><span class="p">{</span>
<span class="ln">2</span>    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="n">Run</span><span class="p">()</span>
<span class="ln">3</span>    <span class="p">{</span>
<span class="ln">4</span>        <span class="c1">// run with average speed and __insane__ endurance
</span><span class="ln">5</span><span class="c1"></span>    <span class="p">}</span>
<span class="ln">6</span><span class="p">}</span>
</code></pre></div>

<p>It&rsquo;s not terrible – At least here we can rely on the default implementation if we just want to give a <code>MarathonRunner</code> &ldquo;average&#8221; abilities in all areas but running.</p>

<p>We might prefer that a <code>MarathonRunner</code> not be required to have <em>any</em> ability to swim or cycle, but that&rsquo;s always the struggle with inheritance-based modeling. You only get to choose one base class to inherit from, and you&rsquo;re bound to get some behavior that you don&rsquo;t need, simply because it&rsquo;s hard to model abstractions using inheritance that avoid giving you more than you need.</p>

<p><a name="default-implementation-with-swift" class="jump-target"></a></p>

<h5 id="default-implementation-with-swift">Default implementation with Swift</h5>

<p>The default implementation story with Swift was non-existent until Swift 2.0 entered the scene. The approach is similar, but as we&rsquo;ll see shortly, provides far more power in terms of composability. Take a look at the implementation that compares most closely with C# for now:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="ln"> 1</span><span class="kd">extension</span> <span class="nc">Athlete</span> <span class="p">{</span>
<span class="ln"> 2</span>    <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// run with average speed and endurance </span>
<span class="ln"> 3</span>    <span class="p">}</span>
<span class="ln"> 4</span>
<span class="ln"> 5</span>    <span class="kd">func</span> <span class="nf">swim</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// swim with average speed and endurance </span>
<span class="ln"> 6</span>    <span class="p">}</span>
<span class="ln"> 7</span>
<span class="ln"> 8</span>    <span class="kd">func</span> <span class="nf">cycle</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// cycle with average speed and endurance </span>
<span class="ln"> 9</span>    <span class="p">}</span>
<span class="ln">10</span><span class="p">}</span></code></pre></div>
<p>Now when we want to model a <code>MarathonRunner</code> in Swift, we can adopt the <code>Athlete</code> protocol, and provide &ldquo;override&#8221; implementations for any of the protocol&rsquo;s requirements that we&rsquo;d like. Anything we don&rsquo;t provide a custom implementation for falls back to the protocol extension&rsquo;s implementation, just like in C#:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="ln">1</span><span class="kd">class</span> <span class="nc">MarathonRunner</span><span class="p">:</span> <span class="n">Athlete</span>
<span class="ln">2</span><span class="p">{</span>
<span class="ln">3</span>    <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
<span class="ln">4</span>        <span class="c1">// run with average speed and __insane__ endurance</span>
<span class="ln">5</span>    <span class="p">}</span>
<span class="ln">6</span><span class="p">}</span></code></pre></div>
<p><a name="similarities" class="jump-target"></a></p>

<h3 id="similarities">Similarities</h3>

<p>Here&rsquo;s a list of the similarities I see between C# abstract classes and Swift protocol extensions:</p>

<ul>
<li>Both outline a set of requirements that either a subclass or a protocol adopter <em>must</em> implement.</li>
<li>Both provide a means to <em>automatically</em> satisfy some (or <em>all</em>) of the requirements by providing a default implementation. With C#, we simply mark the method <code>virtual</code> to allow overriding in the subclass, and provide then an implementation. With Swift, we define a protocol extension that implements one or more of the protocol&rsquo;s requirements.</li>
<li>Both ease the burden of subclasses (C#) or protocol adopters (Swift) to implement all of the requirements when reasonable default implementations could suffice.</li>
<li>Both are used to provide customization points in subclasses (C#) or protocol adopters (Swift), when the default implementation is inadequate.</li>
</ul>

<p><a name="differences" class="jump-target"></a></p>

<h3 id="differences">Differences</h3>

<p>So there are some similarities that I hope you can see and appreciate between C# abstract classes and Swift protocol extensions. But there are some major differences that should also be recognized:</p>

<ul>
<li>Fundamentally, C# abstract classes are a &ldquo;behavior by inheritance&#8221; tool, while Swift protocol extension are a &ldquo;behavior by composition&#8221; tool.</li>
<li>Consequently, C# abstract classes impose a significant limitation: subclasses can inherit from one and only one base class. Swift protocols, on the other hand, can be decomposed into fine-grained, specific requirements that can later be re-combined and composed into more robust and dynamic Type specifications. While C# interfaces provide this same composability, they <em>don&rsquo;t</em> have the ability to provide default implementation, which is a significant difference between the Swift counterpart.</li>
<li>As a consequence of <em>that</em>, subclasses of a C# abstract class get <em>all</em> of the behavior, whether they need (or want) it or not. Swift protocols, being composable, allow a Type to conform to <em>just</em> the pieces it needs. The protocol extension can still exist to provide default behavior when it&rsquo;s appropriate. But if a certain Type needs no ability to [do some thing], it simply drops conforming to that protocol and no superfluous behavior is imposed upon the Type.</li>
</ul>

<p><a name="preference" class="jump-target"></a></p>

<h3 id="preferring-one-over-the-other">Preferring one over the other</h3>

<p>Needless to say, I prefer Swift protocol extensions over C# abstract classes (shocker). I love the composability they offer, while at the same time allowing me to provide default implementations where it&rsquo;s appropriate. In my opinion, Swift protocol extensions are the perfect blend of interface and abstract class in C#. If only C# had &ldquo;interface extensions&#8221;. :]</p>

<p>Since we can apply multiple protocols to a Type to signify what the Type can do, and essentially compose its behavior, how might we diverge from the constraints we had previously when we tried to stick closely with the C# abstract class paradigm?</p>

<p>Recall that I was uncomfortable with making a <code>MarathonRunner</code> have ability to swim and cycle, however &ldquo;average&#8221; that ability may be. What I really want is to break things out a bit more, but still be able to provide that default implementation when I want it.</p>

<p>How might I refactor this by leveraging even more of the power of Swift protocol extensions?</p>

<p><a name="refactoring" class="jump-target"></a></p>

<h3 id="refactoring-for-enhanced-composability-with-swift-protocol-extensions">Refactoring for enhanced composability with Swift protocol extensions</h3>

<p>I think I might like to define 3 protocols instead of 1. Rather than modeling things as <code>Athletes</code>, I&rsquo;d much rather model some athletic <em>behavior</em>, and let the specific <em>kinds</em> of athletes adopt whatever behavior is most appropriate for each athlete type.</p>

<p>So I&rsquo;ll ditch the <code>Athlete</code> protocol, and define these three instead:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="ln"> 1</span><span class="kd">protocol</span> <span class="nc">Runnable</span> <span class="p">{</span>
<span class="ln"> 2</span>    <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span>
<span class="ln"> 3</span><span class="p">}</span>
<span class="ln"> 4</span>
<span class="ln"> 5</span><span class="kd">protocol</span> <span class="nc">Swimmable</span> <span class="p">{</span>
<span class="ln"> 6</span>    <span class="kd">func</span> <span class="nf">swim</span><span class="p">()</span>
<span class="ln"> 7</span><span class="p">}</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span><span class="kd">protocol</span> <span class="nc">Cycleable</span> <span class="p">{</span>
<span class="ln">10</span>    <span class="kd">func</span> <span class="nf">cycle</span><span class="p">()</span>
<span class="ln">11</span><span class="p">}</span></code></pre></div>
<p>Alright&#8230; now&#8230; how about some default implementation?</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="ln"> 1</span><span class="kd">extension</span> <span class="nc">Runnable</span> <span class="p">{</span>
<span class="ln"> 2</span>    <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
<span class="ln"> 3</span>        <span class="c1">// run with average speed and endurance</span>
<span class="ln"> 4</span>    <span class="p">}</span>
<span class="ln"> 5</span><span class="p">}</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span><span class="kd">extension</span> <span class="nc">Swimmable</span> <span class="p">{</span>
<span class="ln"> 8</span>    <span class="kd">func</span> <span class="nf">swim</span><span class="p">()</span> <span class="p">{</span>
<span class="ln"> 9</span>        <span class="c1">// swim with average speed and endurance</span>
<span class="ln">10</span>    <span class="p">}</span>
<span class="ln">11</span><span class="p">}</span>
<span class="ln">12</span>
<span class="ln">13</span><span class="kd">extension</span> <span class="nc">Cycleable</span> <span class="p">{</span>
<span class="ln">14</span>    <span class="kd">func</span> <span class="nf">cycle</span><span class="p">()</span> <span class="p">{</span>
<span class="ln">15</span>        <span class="c1">// cycle with average speed and endurance</span>
<span class="ln">16</span>    <span class="p">}</span>
<span class="ln">17</span><span class="p">}</span></code></pre></div>
<p>Excellent. Now to cap things off, I&rsquo;ll define some Types that adopt <em>just the protocols that are needed</em>:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="ln"> 1</span><span class="kd">struct</span> <span class="nc">MarathonRunner</span><span class="p">:</span> <span class="n">Runnable</span> <span class="p">{</span>
<span class="ln"> 2</span>    <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
<span class="ln"> 3</span>        <span class="c1">// run with average speed and __insane__ endurance</span>
<span class="ln"> 4</span>    <span class="p">}</span>
<span class="ln"> 5</span><span class="p">}</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span><span class="kd">struct</span> <span class="nc">Triathlete</span><span class="p">:</span> <span class="n">Runnable</span><span class="p">,</span> <span class="n">Swimmable</span><span class="p">,</span> <span class="n">Cycleable</span> <span class="p">{</span>
<span class="ln"> 8</span>    <span class="kd">func</span> <span class="nf">swim</span><span class="p">()</span> <span class="p">{</span>
<span class="ln"> 9</span>        <span class="c1">// swim with lightning speed and crazy endurance</span>
<span class="ln">10</span>    <span class="p">}</span>
<span class="ln">11</span>
<span class="ln">12</span>    <span class="c1">// fall back to protocol extension&#39;s average run speed &amp; endurance</span>
<span class="ln">13</span>    <span class="c1">// fall back to protocol extension&#39;s average cycle speed and endurance</span>
<span class="ln">14</span><span class="p">}</span>
<span class="ln">15</span>
<span class="ln">16</span><span class="kd">struct</span> <span class="nc">Andrew</span> <span class="p">{</span>
<span class="ln">17</span>    <span class="c1">// Let&#39;s not impose the re-definition of any of the athletic terms, shall we?</span>
<span class="ln">18</span><span class="p">}</span></code></pre></div>
<p>Notice how the different types of athletes only pick up the behavior that&rsquo;s relevant to their ability. Nothing more, and nothing less.</p>

<p>I also enjoy being able to look at a Type declaration like <code>Triathlete</code> and see that he/she is able to run, swim, and cycle. It feels right to compose abilities this way. And it&rsquo;s even more convenient that some of the <code>Triathlete's</code> behavior is already implemented for me by virtue of the protocol extension.</p>

<h3 id="wrapping-up">Wrapping up</h3>

<p>I hope this analysis helped you see some of the same things I saw when it comes to how abstractions can be modeled with Swift, and how that compares with others languages like C#.</p>

<p><a name="share" class="jump-target"></a></p>

    <aside>
      
      
      <div class="resources">
        <div class="resources-header">
            You might also enjoy...
        </div>
        
        <ul class="resources-content">
            
            <li><i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2014/12/02/send-a-type-to-obedience-school-using-swift-extensions-for-additional-protocol-conformance/">Send a Type to Obedience School – Using Swift Extensions for Additional Protocol Conformance</a></li>
            
            <li><i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2015/07/29/setting-up-carthage-for-the-terminal-timid/">Setting Up Carthage for the Terminal-Timid</a></li>
            
            <li><i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2015/07/22/dissecting-10-read-10-said-my-new-swift-ios-app/">Dissecting 10 Read 10 Said – My New Swift iOS App</a></li>
            
            <li><i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2015/07/16/uitableview-swipe-to-delete-workflow-in-swift/">UITableView Swipe to Delete Workflow in Swift</a></li>
            
            <li><i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2015/07/09/circular-progress-indicator-in-swift/">Circular Progress Indicator in Swift</a></li>
            
        <ul>
      
    </aside>

    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "andrewcbancroft" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </article>



            </div>

        </div>
    </div>

    

    <footer class="footer text-center">
        <div class="container">
            <span class="text-muted">This project contains 176 pages and is available on <a href="https://github.com/andrewcbancroft/andrewcbancroft-blog/tree/master/content/blog">GitHub</a>. Copyright &copy; Andrew Bancroft, <time datetime="2020">2020</time>.</span>
        </div>
    </footer>

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js" integrity="sha384-vFJXuSJphROIrBnz7yo7oB41mKfc8JzQZiCq4NCceLEaO4IHwicKwpJf9c9IpFgh"
        crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js" integrity="sha384-alpBpkh1PFOepccYVYDB4do5UnbKysX5WZXm3XxPqe5iKTfUKjNkCk9SaVuEZflJ"
        crossorigin="anonymous"></script>

</body>

</html>