<!DOCTYPE html>
<html lang="en">

<head>

    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111087893-1"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-111087893-1');
    </script>

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6356224024630676",
            enable_page_level_ads: true
        });
    </script>

    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Receipt Validation – Verifying a Receipt Signature in Swift" />
<meta property="og:description" content="You&#8217;ve prepared to test receipt validation by setting up your app in iTunes Connect. You&#8217;ve brought in a cryptography library like OpenSSL to be able to work with the PKCS #7 container that acts as the &#8220;envelope&#8221; for the receipt. Perhaps you&#8217;ve even done it the &#8220;easy way&#8221; with CocoaPods. You&#8217;ve located and loaded the receipt for validation. You&#8217;ve extracted the PKCS #7 container.  The aim of this guide is to help you take a look inside the PKCS #7 container, and verify the presence and authenticity of the signature on the receipt." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.andrewcbancroft.com/2017/07/16/receipt-validation-verifying-a-receipt-signature-in-swift/" />
<meta property="article:published_time" content="2017-07-16T21:43:21&#43;00:00"/>
<meta property="article:modified_time" content="2017-07-16T21:43:21&#43;00:00"/>

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Receipt Validation – Verifying a Receipt Signature in Swift"/>
<meta name="twitter:description" content="You&#8217;ve prepared to test receipt validation by setting up your app in iTunes Connect. You&#8217;ve brought in a cryptography library like OpenSSL to be able to work with the PKCS #7 container that acts as the &#8220;envelope&#8221; for the receipt. Perhaps you&#8217;ve even done it the &#8220;easy way&#8221; with CocoaPods. You&#8217;ve located and loaded the receipt for validation. You&#8217;ve extracted the PKCS #7 container.  The aim of this guide is to help you take a look inside the PKCS #7 container, and verify the presence and authenticity of the signature on the receipt."/>
<meta name="generator" content="Hugo 0.55.4" /> 
    
    
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "Receipt Validation – Verifying a Receipt Signature in Swift",
  "url": "https:\/\/www.andrewcbancroft.com\/2017\/07\/16\/receipt-validation-verifying-a-receipt-signature-in-swift\/",
  "wordCount": "1797",
  "datePublished": "2017-07-16T21:43:21\x2b00:00",
  "dateModified": "2017-07-16T21:43:21\x2b00:00",
  "author": {
    "@type": "Person",
    "name": "Andrew"
  },
  "keywords": "Swift, Receipt Validation"
}
</script>



    <title>Receipt Validation – Verifying a Receipt Signature in Swift</title>

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb"
        crossorigin="anonymous">

    
    <link href="https://www.andrewcbancroft.com/css/custom.css" rel="stylesheet"> 
    <link href="https://www.andrewcbancroft.com/css/syntax.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Muli:400,500,700" rel="stylesheet">
        
    <link href="" rel="alternate" type="application/rss+xml" title="Andrew Bancroft" /> 
    
    <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

</head>

<body>

    <nav class="navbar navbar-expand-sm fixed-top">
        <div class="container">
            <a class="navbar-brand" href="https://www.andrewcbancroft.com">Andrew Bancroft</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
                aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="nav navbar-nav mr-auto"></ul>
                <ul class="navbar-nav">
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true"
                            aria-expanded="false">
                            Notes
                        </a>
                        <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown">
                            <a class="dropdown-item" href="https://www.andrewcbancroft.com#sql-server-notes">SQL Server</a>
                        </div>
                    </li>
                    <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true"
                                aria-expanded="false">
                                Blog Articles
                            </a>
                            <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown">
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#azure">Azure</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#dimensional-modeling">Dimensional Modeling</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#general-data-concepts">General Data Concepts</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#machine-learning">Machine Learning</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#r">R</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#sql-server">SQL Server</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#statistics">Statistics</a>
                            </div>
                        </li>
                    
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true"
                            aria-expanded="false">
                            About
                        </a>
                        <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown">
                            <a class="dropdown-item" href="https://www.andrewcbancroft.comabout/andrew_bancroft/">About Andrew</a>
                            <a class="dropdown-item" href="https://github.com/andrewcbancroft">GitHub</a>
                            <a class="dropdown-item" href="https://www.linkedin.com/in/andrewcbancroft/">LinkedIn</a>
                            <a class="dropdown-item" href="https://twitter.com/andrewcbancroft">Twitter</a>
                            <a class="dropdown-item" href="https://www.youtube.com/channel/UCDPV9kMhP-b5EFRI7d812pg">YouTube</a>
                            <a class="dropdown-item" href="https://www.pluralsight.com/authors/andrew-bancroft">Pluralsight Courses</a>
                            <a class="dropdown-item" href="https://www.andrewcbancroft.com">www.andrewcbancroft.com</a>
                        </div>
                    </li>
                </ul>
            </div>
        </div>
    </nav>


    
    <div class="container">
        <div class="row">
            <div class="col-sm-12">

                


<article>
  <div class="article">
    <header>
      <h1 class="article-title">Receipt Validation – Verifying a Receipt Signature in Swift</h1>
    </header>
    <div class="content">

    

<ul>
<li>You&#8217;ve <a href="https://www.andrewcbancroft.com/2015/10/05/preparing-to-test-receipt-validation-for-ios/">prepared to test receipt validation</a> by setting up your app in iTunes Connect.</li>
<li>You&#8217;ve brought in a cryptography library like OpenSSL to be able to work with the PKCS #7 container that acts as the &#8220;envelope&#8221; for the receipt. Perhaps you&#8217;ve even done it <a href="https://www.andrewcbancroft.com/2015/09/21/openssl-for-ios-swift-the-easy-way/">the &#8220;easy way&#8221; with CocoaPods</a>.</li>
<li>You&#8217;ve <a href="https://www.andrewcbancroft.com/2015/10/13/loading-a-receipt-for-validation-with-swift/">located and loaded</a> the receipt for validation.</li>
<li>You&#8217;ve <a href="https://www.andrewcbancroft.com/2016/06/09/extracting-a-pkcs7-container-for-receipt-validation-with-swift/">extracted the PKCS #7 container</a>.</li>
</ul>

<p>The aim of this guide is to help you take a look <em>inside</em> the PKCS #7 container, and verify the presence and authenticity of the signature on the receipt.</p>

<p>Just want the code? Here you go!</p>

<div class="resources">
  <div class="resources-header">
    Resources
  </div>
  

<p><ul class="resources-content">
    <li>
      <i class="fa fa-github fa-lg"></i> <a href="https://github.com/andrewcbancroft/SwiftyLocalReceiptValidator">Swifty Local Receipt Validator</a>
    </li>
  </ul>
</div></p>

<div class="resources">
  <div class="resources-header">
    Jump to&#8230;
  </div>
  

<p><ul class="resources-content">
    <li>
      <a href="#recap">Recap from the previous guide</a>
    </li>
    <li>
      <a href="#apple-root-cert">Preparation step: Download Apple&#8217;s root certificate</a>
    </li>
    <li>
      <a href="#what-can-go-wrong">What can go wrong with receipt signature verification?</a>
    </li>
    <li>
      <a href="#concept">ReceiptSignatureValidator concept</a>
    </li>
    <li>
      <a href="#implementation">ReceiptSignatureValidator implementation</a>
    </li>
    <ul>
      <li>
        <a href="#signature-presence">Checking signature presence</a>
      </li>
      <li>
        <a href="#signature-authenticity">Checking signature authenticity</a>
      </li>
      <ul>
        <li>
          <a href="#load-apple-root-cert">Loading Apple&#8217;s root certificate</a>
        </li>
        <li>
          <a href="#verify-authenticity">Verifying signature authenticity</a>
        </li>
      </ul>
    </ul></p>

<pre><code>&lt;li&gt;
  &lt;a href=&quot;#putting-it-all-together&quot;&gt;Putting it all together&lt;/a&gt;
&lt;/li&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;a href=&quot;#final-implementation&quot;&gt;Final ReceiptSignatureValidator implementation&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;#additions-to-receipt-validator&quot;&gt;Additions to ReceiptValidator&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;#handling-errors&quot;&gt;Handling errors&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;li&gt;
  &lt;a href=&quot;#upcoming-hurdles&quot;&gt;Upcoming hurdles&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
  &lt;a href=&quot;#related&quot;&gt;You might also enjoy&amp;#8230;&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
  &lt;a href=&quot;#share&quot;&gt;Was this article helpful? Please share!&lt;/a&gt;
&lt;/li&gt;
</code></pre>

<p></ul>
</div></p>

<p><a name="recap" class="jump-target"></a></p>

<h1 id="recap-from-the-previous-guide">Recap from the previous guide</h1>

<p>In <a href="https://www.andrewcbancroft.com/2015/10/13/loading-a-receipt-for-validation-with-swift/">Loading a Receipt for Validation with Swift</a>, I began the process of breaking out the various steps of the receipt validation process into separate single-responsibility structs with clearly named functions to help clarify what each piece of code is doing.</p>

<p>Recall that I’ve <a href="https://www.andrewcbancroft.com/2015/10/13/loading-a-receipt-for-validation-with-swift/#receipt-validator-implementation">created a main Type called <code>ReceiptValidator</code></a>, with references to several smaller single-responsibility Types that it uses to accomplish the overall validation process.</p>

<p>Accordingly, I’ve <a href="https://www.andrewcbancroft.com/2015/10/13/loading-a-receipt-for-validation-with-swift/#receipt-loader-implementation">created a ReceiptLoader</a> that finds the receipt on the file system and loads it into memory.</p>

<p>As of the last entry in this series of guides, I&#8217;ve also <a href="https://www.andrewcbancroft.com/2016/06/09/extracting-a-pkcs7-container-for-receipt-validation-with-swift/#receiptextractor-implementation">got a <code>ReceiptExtractor</code></a> to extract the receipt contents from its PKCS #7 container.</p>

<p>If a validation step ever fails along the way, I’ve decided to take advantage of Swift’s error throwing features to clearly describe what failed. So far, there’s only two cases:</p>

<pre class="lang:swift decode:true " title="ReceiptValidationError" >enum ReceiptValidationError : Error {
    case couldNotFindReceipt
    case emptyReceiptContents
}</pre>

<p><a name="apple-root-cert" class="jump-target"></a></p>

<h1 id="preparation-step-download-apple-8217-s-root-certificate">Preparation step: Download Apple&#8217;s root certificate</h1>

<p>You need a copy of Apple&#8217;s root certificate in order to fully complete this phase of receipt validation.</p>

<p>How do you get a copy of it? Great question (with an answer)!</p>

<p>If you go to <a href="https://www.apple.com/certificateauthority/">https://www.apple.com/certificateauthority/</a>, you can get your hands on a copy by downloading the &#8220;Apple Inc. Root Certificate&#8221; file:</p>

<p><a href="https://www.andrewcbancroft.com/wp-content/uploads/2015/10/Apple_PKI.png"><img src="https://www.andrewcbancroft.com/wp-content/uploads/2015/10/Apple_PKI.png" alt="Apple Certificate Page" width="798" height="688" class="alignnone size-full wp-image-12375" srcset="https://www.andrewcbancroft.com/wp-content/uploads/2015/10/Apple_PKI.png 798w, https://www.andrewcbancroft.com/wp-content/uploads/2015/10/Apple_PKI-300x259.png 300w" sizes="(max-width: 798px) 100vw, 798px" /></a></p>

<p>Once you have it, you need to add the certificate to your Xcode project, and add it to your app&#8217;s target:<br />
<a href="https://www.andrewcbancroft.com/wp-content/uploads/2016/06/root_cert_target_membership.png"><img src="https://www.andrewcbancroft.com/wp-content/uploads/2016/06/root_cert_target_membership-1024x621.png" alt="Apple Root Certificate Target Membership" width="1024" height="621" class="alignnone size-large wp-image-12920" srcset="https://www.andrewcbancroft.com/wp-content/uploads/2016/06/root_cert_target_membership-1024x621.png 1024w, https://www.andrewcbancroft.com/wp-content/uploads/2016/06/root_cert_target_membership-300x182.png 300w, https://www.andrewcbancroft.com/wp-content/uploads/2016/06/root_cert_target_membership.png 1223w" sizes="(max-width: 1024px) 100vw, 1024px" /></a></p>

<p><a name="what-can-go-wrong" class="jump-target"></a></p>

<h1 id="what-can-go-wrong-with-receipt-signature-verification">What can go wrong with receipt signature verification?</h1>

<p>I&#8217;ll start off the code piece of this guide by asking, &#8220;What could go wrong?&#8221;. That&#8217;ll help define a few more <code>ReceiptValidationError</code> cases, and might point us in a direction when it comes to implementing a new Type to use within the <code>ReceiptValidator</code>.</p>

<p>Right off the bat, I can think of two or three things that could go awry at this stage of the receipt validation process:</p>

<p>1 &#8211; The receipt that we loaded may not be signed at all<br />
2 &#8211; We don&#8217;t have a copy of Apple&#8217;s root certificate to validate the signature with<br />
3 &#8211; The signature on the receipt is invalid because it doesn&#8217;t match against Apple&#8217;s root certificate</p>

<p>I&#8217;ll add those three new error states to the <code>ReceiptValidationError</code> enum now:</p>

<pre class="lang:swift decode:true mark:4-6" title="ReceiptValidationError" >enum ReceiptValidationError : Error {
    case couldNotFindReceipt
    case emptyReceiptContents
    case receiptNotSigned
    case appleRootCertificateNotFound
    case receiptSignatureInvalid
}</pre>

<p><a name="concept" class="jump-target"></a></p>

<h1 id="receiptsignaturevalidator-concept">ReceiptSignatureValidator concept</h1>

<p>Another step, another Type. This has been my strategy so far, so I&#8217;m stickin&#8217; to it!</p>

<p>I&#8217;m validating the <strong>presence</strong> and <strong>authenticity</strong> of the signature on the receipt, so I picked the name <code>ReceiptSignatureValidator</code> for this one.</p>

<p>When I identified three new <code>ReceiptValidationError</code> cases earlier, I had in mind that they could potentially point me in a direction when implementing this new <code>ReceiptSignatureValidator</code> Type.</p>

<p>What if this Type had two functions?</p>

<ul>
<li><code>checkSignaturePresence</code></li>
<li><code>checkSignatureAuthenticity</code></li>
</ul>

<p>In <code>checkSignaturePresence</code>, I&#8217;ll look, and if the receipt isn&#8217;t signed at all, I&#8217;ll throw the <code>receiptNotSigned</code> Error case.</p>

<p>In <code>checkSignatureAuthenticity</code>, I&#8217;ll look, and if the Apple root certificate is missing from the bundle for some reason, I&#8217;ll throw <code>appleRootCertificateNotFound</code>. And if the signature on the receipt doesn&#8217;t jive with Apple&#8217;s root certificate, I&#8217;ll throw <code>receiptSignatureInvalid</code>.</p>

<p>Here&#8217;s the skeleton of the struct:</p>

<pre class="lang:swift decode:true " title="ReceiptSignatureValidator" >struct ReceiptSignatureValidator {
    func checkSignaturePresence(_ PKCS7Container: UnsafeMutablePointer&lt;PKCS7&gt;) throws {
        // Implementation coming
    }
    
    func checkSignatureAuthenticity(_ PKCS7Container: UnsafeMutablePointer&lt;PKCS7&gt;) throws {
        // Implementation coming
    }
}</pre>

<p>Both <code>checkSignaturePresence</code> and <code>checkSignatureAuthenticity</code> need to peek into the PKCS #7 container that encapsulates the receipt data, so each function asks for a reference to an <code>UnsafeMutablePointer&lt;PKCS7&gt;</code> as one of its arguments.</p>

<p>If you&#8217;re following along with the series, you&#8217;ll be glad to know that <a href="https://www.andrewcbancroft.com/2016/06/09/extracting-a-pkcs7-container-for-receipt-validation-with-swift/#receiptextractor-implementation">the <code>ReceiptExtractor</code> that we built previously</a> has a method called <code>extractPKCS7Container</code> that actually <em>returns</em> a <code>UnsafeMutablePointer&lt;PKCS7&gt;</code>, so you can just use the a call to <code>extractPKCS7Container</code> with the new <code>ReceiptSignatureValidator's</code> functions.</p>

<p><a name="implementation" class="jump-target"></a></p>

<h1 id="receiptsignaturevalidator-implementation">ReceiptSignatureValidator implementation</h1>

<p>Now to actually <em>implement</em> <code>ReceiptSignatureValidator</code>&#8230;</p>

<p><a name="signature-presence" class="jump-target"></a></p>

<h2 id="checking-signature-presence">Checking signature presence</h2>

<p>Checking for the presence of a signature is actually relatively simple. Take a look:</p>

<pre class="lang:swift decode:true mark:3,5-7" title="ReceiptSignatureValidator" >struct ReceiptSignatureValidator {
    func checkSignaturePresence(_ PKCS7Container: UnsafeMutablePointer&lt;PKCS7&gt;) throws {
        let pkcs7SignedTypeCode = OBJ_obj2nid(PKCS7Container.pointee.type)
        
        guard pkcs7SignedTypeCode == NID_pkcs7_signed else {
            throw ReceiptValidationError.receiptNotSigned
        }
    }
    
    func checkSignatureAuthenticity(_ PKCS7Container: UnsafeMutablePointer&lt;PKCS7&gt;) throws {
        // Implementation coming
    }
}
</pre>

<p>The PKCS #7 container has a type code associated with it if it&#8217;s <em>signed</em>. All we need to do is access that type code, and compare it against the <code>NID_pkcs7_signed</code> constant.</p>

<p>In order to be valid, the receipt <em>must</em> be signed, so I&#8217;ve implemented this as a guard.</p>

<p><a name="signature-authenticity" class="jump-target"></a></p>

<h2 id="checking-signature-authenticity">Checking signature authenticity</h2>

<p><a name="load-apple-root-cert" class="jump-target"></a></p>

<h3 id="loading-apple-8217-s-root-certificate">Loading Apple&#8217;s root certificate</h3>

<p>Now comes the part where we check whether the signature on the receipt is authentic or not.</p>

<p>First, we&#8217;ve got to load up Apple&#8217;s root certificate (assuming it exists in the app bundle). Here&#8217;s a function that can be nested inside of <code>ReceiptSignatureValidator</code> to do the job:</p>

<pre class="lang:swift decode:true " title="loadAppleRootCertificate" >fileprivate func loadAppleRootCertificate() throws -> UnsafeMutablePointer&lt;X509> {
    guard
        let appleRootCertificateURL = Bundle.main.url(forResource: "AppleIncRootCertificate", withExtension: "cer"),
        let appleRootCertificateData = try? Data(contentsOf: appleRootCertificateURL)
        else {
            throw ReceiptValidationError.appleRootCertificateNotFound
    }
    
    //①
    let appleRootCertificateBIO = BIO_new(BIO_s_mem())

    //②
    BIO_write(appleRootCertificateBIO, (appleRootCertificateData as NSData).bytes, Int32(appleRootCertificateData.count))

    //③
    let appleRootCertificateX509 = d2i_X509_bio(appleRootCertificateBIO, nil)
    
    return appleRootCertificateX509!
}</pre>

<p>This function guards against the absence of Apple&#8217;s root certificate. If it can&#8217;t be found in the main bundle, the function throws <code>appleRootCertificateNotFound</code>. This error is obviously preventable, but hey &#8211; never hurts to protect yourself if you&#8217;re using this code in multiple projects and forget to grab a copy of Apple&#8217;s root certificate.</p>

<p>① As long as the .cer file exists in the app bundle, the next step is to create a new in-memory BIO (basic input-output) pointer. That&#8217;s what <code>let appleRootCertificateBIO = BIO_new(BIO_s_mem())</code> does.</p>

<p>② Next, we&#8217;ve got to write the contents of the certificate to memory so we can work with it:</p>

<pre class="lang:swift decode:true " title="BIO_write">BIO_write(appleRootCertificateBIO, (appleRootCertificateData as NSData).bytes, Int32(appleRootCertificateData.count))
</pre>

<p><code>BIO_write</code> needs a location to write to, namely, our <code>appleRootCertificateBIO</code> pointer.</p>

<p>It also needs to know <em>what</em> to write: <code>(appleRootCertificateData as NSData).bytes</code></p>

<p>Finally, it needs to know the length of the data to write: <code>Int32(appleRootCertificateData.count)</code></p>

<p>③ Once that&#8217;s complete, we can obtain pointer to an <code>X509</code>, which will be used for the next step: verifying the authenticity of the signature on the receipt with the x509 certificate from Apple&#8217;s root certificate authority. <code>let appleRootCertificateX509 = d2i_X509_bio(appleRootCertificateBIO, nil)</code> gives us our return value!</p>

<p><a name="verify-authenticity" class="jump-target"></a></p>

<h3 id="verifying-signature-authenticity">Verifying signature authenticity</h3>

<p>The final step is to take the <code>X509</code> pointer, and use it to verify the authenticity of the signature on the PKCS #7 Container.</p>

<p>Once again, here&#8217;s a function that can take both items and do the work:</p>

<pre class="lang:swift decode:true " title="verifyAuthenticity" >fileprivate func verifyAuthenticity(_ x509Certificate: UnsafeMutablePointer&lt;X509&gt;, PKCS7Container: UnsafeMutablePointer&lt;PKCS7&gt;) throws {
    //①
    let x509CertificateStore = X509_STORE_new()

    //②
    X509_STORE_add_cert(x509CertificateStore, x509Certificate)
    
    //③
    OpenSSL_add_all_digests()
    
    //④
    let result = PKCS7_verify(PKCS7Container, nil, x509CertificateStore, nil, nil, 0)
    
    //⑤
    if result != 1 {
        throw ReceiptValidationError.receiptSignatureInvalid
    }
}</pre>

<p>① The X509 Store is what holds the information for verification, so we use <code>X509_STORE_new()</code> to create one.</p>

<p>② Next, <code>X509_STORE_add_cert</code> function is used to prepare the X509 Store, and the X509 <em>Certificate</em> for verification purposes.</p>

<p>③ OpenSSL keeps an internal table of digest algorithms and ciphers. It uses this table to lookup ciphers via certain functions. <code>OpenSSL_add_all_digests()</code> is called to load the necessary digest algorithms for verification.</p>

<p>④ The final step is to use the <code>PKCS7_verify</code> function, passing it the PKCS #7 Container, and the x509 Certificate Store.</p>

<p>⑤ <code>PKCS7_Verify</code> will return <strong>1</strong> if the signature is valid. If <code>PKCS7_Verify</code> returns any integer value <em>other than</em> 1, the signature is to be interpreted as <em>invalid</em>.</p>

<p><a name="putting-it-all-together" class="jump-target"></a></p>

<h1 id="putting-it-all-together">Putting it all together</h1>

<p><a name="final-implementation" class="jump-target"></a></p>

<h2 id="final-receiptsignaturevalidator-implementation">Final ReceiptSignatureValidator implementation</h2>

<p>The final version of the <code>ReceiptSignatureValidator</code> looks like this:</p>

<pre class="lang:swift decode:true " title="Final ReceiptSignatureValidator" >struct ReceiptSignatureValidator {
    func checkSignaturePresence(_ PKCS7Container: UnsafeMutablePointer&lt;PKCS7&gt;) throws {
        let pkcs7SignedTypeCode = OBJ_obj2nid(PKCS7Container.pointee.type)
        
        guard pkcs7SignedTypeCode == NID_pkcs7_signed else {
            throw ReceiptValidationError.receiptNotSigned
        }
    }
    
    func checkSignatureAuthenticity(_ PKCS7Container: UnsafeMutablePointer&lt;PKCS7&gt;) throws {
        let appleRootCertificateX509 = try loadAppleRootCertificate()
        
        try verifyAuthenticity(appleRootCertificateX509, PKCS7Container: PKCS7Container)
    }
    
    fileprivate func loadAppleRootCertificate() throws -&gt; UnsafeMutablePointer&lt;X509&gt; {
        guard
            let appleRootCertificateURL = Bundle.main.url(forResource: "AppleIncRootCertificate", withExtension: "cer"),
            let appleRootCertificateData = try? Data(contentsOf: appleRootCertificateURL)
            else {
                throw ReceiptValidationError.appleRootCertificateNotFound
        }
        
        let appleRootCertificateBIO = BIO_new(BIO_s_mem())
        BIO_write(appleRootCertificateBIO, (appleRootCertificateData as NSData).bytes, Int32(appleRootCertificateData.count))
        let appleRootCertificateX509 = d2i_X509_bio(appleRootCertificateBIO, nil)
        
        return appleRootCertificateX509!
    }
    
    fileprivate func verifyAuthenticity(_ x509Certificate: UnsafeMutablePointer&lt;X509&gt;, PKCS7Container: UnsafeMutablePointer&lt;PKCS7&gt;) throws {
        let x509CertificateStore = X509_STORE_new()
        X509_STORE_add_cert(x509CertificateStore, x509Certificate)
        
        OpenSSL_add_all_digests()
        
        let result = PKCS7_verify(PKCS7Container, nil, x509CertificateStore, nil, nil, 0)
        
        if result != 1 {
            throw ReceiptValidationError.receiptSignatureInvalid
        }
    }
}</pre>

<p><a name="additions-to-receipt-validator" class="jump-target"></a></p>

<h2 id="additions-to-receiptvalidator">Additions to ReceiptValidator</h2>

<p>The <code>ReceiptValidator</code> struct that&#8217;s been growing to accommodate each of the steps now looks like this (additions highlighted):</p>

<pre class="lang:swift decode:true mark:4,12-13" title="ReceiptValidator" >struct ReceiptValidator {
    let receiptLoader = ReceiptLoader()
    let receiptExtractor = ReceiptExtractor()
    let receiptSignatureValidator = ReceiptSignatureValidator()

    
    func validateReceipt() -> ReceiptValidationResult {
        do {
            let receiptData = try receiptLoader.loadReceipt()
            let receiptContainer = try receiptExtractor.extractPKCS7Container(receiptData)
            
            try receiptSignatureValidator.checkSignaturePresence(receiptContainer)
            try receiptSignatureValidator.checkSignatureAuthenticity(receiptContainer)
            return .success
        } catch {
            return .error(error as! ReceiptValidationError)
        }
    }
}</pre>

<p><a name="handling-errors" class="jump-target"></a></p>

<h2 id="handling-errors">Handling errors</h2>

<p>The final piece is to attempt to do something intelligent with any of the possible error conditions that could be included with the <code>ReceiptValidator</code> validation result. Here&#8217;s a sample implementation at the call site for <code>validateReceipt()</code> (probably in a view controller somewhere in your app:</p>

<pre>override public func viewDidLoad() {
    super.viewDidLoad()

    let validationResult = receiptValidator.validateReceipt()
        
    switch validationResult {
    case .success:
        // Enable app features
    case .error(let error):
        print(error)
        receiptRequest.start()
    }   
}
</pre>

<p>In the case where the receipt signature is invalid, my only thought right now is to request a new receipt from the app store and attempt to re-validate it.</p>

<p><a name="upcoming-hurdles" class="jump-target"></a></p>

<h1 id="upcoming-hurdles">Upcoming hurdles</h1>

<p>Wait, there&#8217;s more? In short, yes. We&#8217;ve made significant progress, but <a href="https://developer.apple.com/library/content/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateLocally.html#//apple_ref/doc/uid/TP40010573-CH1-SW2">there&#8217;s still more work to be done</a> if you want to fully validate a receipt for your app, or for an in-app purchase.</p>

<p><a name="related" class="jump-target"></a></p>

<div class="resources">
  <div class="resources-header">
    You might also enjoy&#8230;
  </div>
  

<p><ul class="resources-content">
    <li>
      <i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2015/10/05/preparing-to-test-receipt-validation-for-ios/" title="Preparing to Test Receipt Validation for iOS">Preparing to Test Receipt Validation for iOS</a>
    </li>
    <li>
      <i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2015/10/13/loading-a-receipt-for-validation-with-swift/" title="Loading a Receipt for Validation with Swift">Loading a Receipt for Validation with Swift</a>
    </li>
    <li>
      <i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2015/09/21/openssl-for-ios-swift-the-easy-way/" title="OpenSSL for iOS &#038; Swift the Easy Way">OpenSSL for iOS &amp; Swift the Easy Way</a>
    </li>
    <li>
      <i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2016/06/09/extracting-a-pkcs7-container-for-receipt-validation-with-swift/" title="Extracting a PKCS7 Container for Receipt Validation with Swift">Extracting a PKCS7 Container for Receipt Validation with Swift</a>
    </li>
    <li>
      <i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2017/07/27/receipt-validation-parsing-a-receipt-with-swift/" title="Receipt Validation – Parse and Decode a Receipt with Swift">Receipt Validation – Parse and Decode a Receipt with Swift</a>
    </li>
    <li>
      <i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2017/07/31/finalizing-receipt-validation-in-swift-computing-a-guid-hash/" title="Finalizing Receipt Validation in Swift – Computing a GUID Hash">Finalizing Receipt Validation in Swift – Computing a GUID Hash</a>
    </li>
  </ul>
</div></p>

<p><a name="share" class="jump-target"></a></p>


    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "andrewcbancroft" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </article>



            </div>

        </div>
    </div>

    

    <footer class="footer text-center">
        <div class="container">
            <span class="text-muted">This project contains 146 pages and is available on <a href="https://github.com/andrewcbancroft/datadaylife-blog">GitHub</a>. Copyright &copy; Andrew Bancroft, <time datetime="2019">2019</time>.</span>
        </div>
    </footer>

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js" integrity="sha384-vFJXuSJphROIrBnz7yo7oB41mKfc8JzQZiCq4NCceLEaO4IHwicKwpJf9c9IpFgh"
        crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js" integrity="sha384-alpBpkh1PFOepccYVYDB4do5UnbKysX5WZXm3XxPqe5iKTfUKjNkCk9SaVuEZflJ"
        crossorigin="anonymous"></script>

</body>

</html>