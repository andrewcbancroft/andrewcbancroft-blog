<!DOCTYPE html>
<html lang="en">

<head>

    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111087893-1"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-111087893-1');
    </script>

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6356224024630676",
            enable_page_level_ads: true
        });
    </script>

    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Receipt Validation –  Parse and Decode a Receipt with Swift" />
<meta property="og:description" content="The aim of this guide is to help you parse a receipt and decode it so that you have readable pieces of metadata to inspect and finalize all of the receipt validation steps.
This is a continuation of my receipt validation series. I'm assuming that&#8230;
 You've prepared to test receipt validation by setting up your app in iTunes Connect. You've brought in a cryptography library like OpenSSL to be able to work with the PKCS #7 container that acts as the &#8220;envelope&#8221; for the receipt." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.andrewcbancroft.com/2017/07/27/receipt-validation-parsing-a-receipt-with-swift/" />
<meta property="article:published_time" content="2017-07-28T03:41:33&#43;00:00"/>
<meta property="article:modified_time" content="2017-07-28T03:41:33&#43;00:00"/>

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Receipt Validation –  Parse and Decode a Receipt with Swift"/>
<meta name="twitter:description" content="The aim of this guide is to help you parse a receipt and decode it so that you have readable pieces of metadata to inspect and finalize all of the receipt validation steps.
This is a continuation of my receipt validation series. I'm assuming that&#8230;
 You've prepared to test receipt validation by setting up your app in iTunes Connect. You've brought in a cryptography library like OpenSSL to be able to work with the PKCS #7 container that acts as the &#8220;envelope&#8221; for the receipt."/>
<meta name="generator" content="Hugo 0.55.4" /> 
    
    
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "Receipt Validation –  Parse and Decode a Receipt with Swift",
  "url": "https:\/\/www.andrewcbancroft.com\/2017\/07\/27\/receipt-validation-parsing-a-receipt-with-swift\/",
  "wordCount": "3386",
  "datePublished": "2017-07-28T03:41:33\x2b00:00",
  "dateModified": "2017-07-28T03:41:33\x2b00:00",
  "author": {
    "@type": "Person",
    "name": "Andrew"
  },
  "keywords": "Swift, Receipt Validation"
}
</script>



    <title>Receipt Validation –  Parse and Decode a Receipt with Swift</title>

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb"
        crossorigin="anonymous">

    
    <link href="https://www.andrewcbancroft.com/css/custom.css" rel="stylesheet"> 
    <link href="https://www.andrewcbancroft.com/css/syntax.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Muli:400,500,700" rel="stylesheet">
        
    <link href="" rel="alternate" type="application/rss+xml" title="Andrew Bancroft" /> 
    
    <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

</head>

<body>

    <nav class="navbar navbar-expand-sm fixed-top">
        <div class="container">
            <a class="navbar-brand" href="https://www.andrewcbancroft.com">Andrew Bancroft</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
                aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="nav navbar-nav mr-auto"></ul>
                <ul class="navbar-nav">
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true"
                            aria-expanded="false">
                            Notes
                        </a>
                        <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown">
                            <a class="dropdown-item" href="https://www.andrewcbancroft.com#sql-server-notes">SQL Server</a>
                        </div>
                    </li>
                    <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true"
                                aria-expanded="false">
                                Blog Articles
                            </a>
                            <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown">
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#azure">Azure</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#dimensional-modeling">Dimensional Modeling</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#general-data-concepts">General Data Concepts</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#machine-learning">Machine Learning</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#r">R</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#sql-server">SQL Server</a>
                                <a class="dropdown-item" href="https://www.andrewcbancroft.com#statistics">Statistics</a>
                            </div>
                        </li>
                    
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true"
                            aria-expanded="false">
                            About
                        </a>
                        <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown">
                            <a class="dropdown-item" href="https://www.andrewcbancroft.comabout/andrew_bancroft/">About Andrew</a>
                            <a class="dropdown-item" href="https://github.com/andrewcbancroft">GitHub</a>
                            <a class="dropdown-item" href="https://www.linkedin.com/in/andrewcbancroft/">LinkedIn</a>
                            <a class="dropdown-item" href="https://twitter.com/andrewcbancroft">Twitter</a>
                            <a class="dropdown-item" href="https://www.youtube.com/channel/UCDPV9kMhP-b5EFRI7d812pg">YouTube</a>
                            <a class="dropdown-item" href="https://www.pluralsight.com/authors/andrew-bancroft">Pluralsight Courses</a>
                            <a class="dropdown-item" href="https://www.andrewcbancroft.com">www.andrewcbancroft.com</a>
                        </div>
                    </li>
                </ul>
            </div>
        </div>
    </nav>


    
    <div class="container">
        <div class="row">
            <div class="col-sm-12">

                


<article>
  <div class="article">
    <header>
      <h1 class="article-title">Receipt Validation –  Parse and Decode a Receipt with Swift</h1>
    </header>
    <div class="content">

    

<p>The aim of this guide is to help you parse a receipt and decode it so that you have readable pieces of metadata to inspect and finalize all of the receipt validation steps.</p>

<p>This is a continuation of my receipt validation series. I'm assuming that&#8230;</p>

<ul>
<li>You've <a href="https://www.andrewcbancroft.com/2015/10/05/preparing-to-test-receipt-validation-for-ios/">prepared to test receipt validation</a> by setting up your app in iTunes Connect.</li>
<li>You've brought in a cryptography library like OpenSSL to be able to work with the PKCS #7 container that acts as the &#8220;envelope&#8221; for the receipt. Perhaps you've even done it <a href="https://www.andrewcbancroft.com/2015/09/21/openssl-for-ios-swift-the-easy-way/">the &#8220;easy way&#8221; with CocoaPods</a>.</li>
<li>You've <a href="https://www.andrewcbancroft.com/2015/10/13/loading-a-receipt-for-validation-with-swift/">located and loaded</a> the receipt for validation.</li>
<li>You've <a href="https://www.andrewcbancroft.com/2016/06/09/extracting-a-pkcs7-container-for-receipt-validation-with-swift/">extracted the PKCS #7 container</a>.</li>
<li>You've <a href="https://www.andrewcbancroft.com/2017/07/16/receipt-validation-verifying-a-receipt-signature-in-swift/">verified the signature on the receipt</a></li>
</ul>

<p>After finishing this guide, you'll still have to <a href="https://www.andrewcbancroft.com/2017/07/31/finalizing-receipt-validation-in-swift-computing-a-guid-hash/">compute the GUID hash of your app</a> to compare with the hash that's found within the receipt. You'll also have to inspect the receipt data to perform any app-specific verification steps. But in order to do either, you'll need the parsed receipt metadata.</p>

<p>Just want the code? Here you go!</p>

<div class="resources">
  <div class="resources-header">
    Resources
  </div>
  

<p><ul class="resources-content">
    <li>
      <i class="fa fa-github fa-lg"></i> <a href="https://github.com/andrewcbancroft/SwiftyLocalReceiptValidator">Swifty Local Receipt Validator</a>
    </li>
  </ul>
</div></p>

<p>Want to understand the final <code>ReceiptParser</code>? Let's get to it!</p>

<div class="resources">
  <div class="resources-header">
    Jump to&#8230;
  </div>
  

<p><ul class="resources-content">
    <li>
      <a href="#final-goal">The final goal: A parsed receipt</a>
    </li>
    <li>
      <a href="#visualizing-receipt-structure">Visualizing the encoded receipt's structure</a>
    </li>
    <li>
      <a href="#parsing-strategy">Receipt parsing strategy</a>
    </li>
    <ul>
      <li>
        <a href="#note-on-iap-receipts">A note on in-app purchase receipts</a>
      </li>
    </ul></p>

<pre><code>&lt;li&gt;
  &lt;a href=&quot;#helper-functions&quot;&gt;Preparation step: Helper decoding functions&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
  &lt;a href=&quot;#handling-error-conditions&quot;&gt;Handling error conditions&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
  &lt;a href=&quot;#implementing-receipt-parser&quot;&gt;Implenting ReceiptParser&lt;/a&gt;
&lt;/li&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;a href=&quot;#parse-function-implementation&quot;&gt;parse function implementation&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;#parse-in-app-purchase-receipt-implementation&quot;&gt;parseInAppPurchaseRectipt function implementation&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;li&gt;
  &lt;a href=&quot;#final-receipt-parser&quot;&gt;Final ReceiptParser&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
  &lt;a href=&quot;#using-receipt-parser&quot;&gt;Using ReceiptParser&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
  &lt;a href=&quot;#preparing-to-finish-receipt-validation&quot;&gt;Preparing to finish receipt validation!&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
  &lt;a href=&quot;#related&quot;&gt;You might also enjoy&amp;#8230;&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
  &lt;a href=&quot;#share&quot;&gt;Was this article helpful? Please share!&lt;/a&gt;
&lt;/li&gt;
</code></pre>

<p></ul>
</div></p>

<p><a name="final-goal" class="jump-target"></a></p>

<h1 id="the-final-goal-a-parsed-receipt">The final goal: A parsed receipt</h1>

<p>The final goal of this guide is a parsed receipt.</p>

<p>What do you say we start things off by defining what one looks like?</p>

<p>At the end of the day, what we'd like back from the parsing process is a simple struct that contains the various pieces of metadata that are found within the <a href="https://www.andrewcbancroft.com/2016/06/09/extracting-a-pkcs7-container-for-receipt-validation-with-swift/">extracted the PKCS #7 container</a>. Things like&#8230;</p>

<ul>
<li>the app's bundle identifier,</li>
<li>the original app version that was purchased,</li>
<li>a collection of all the in app purchase receipts,</li>
<li>etc.</li>
</ul>

<p>How does the following look?</p>

<pre class="lang:swift decode:true " title="ParsedReceipt | ParsedInAppPurchaseReceipt" >struct ParsedReceipt {
    let bundleIdentifier: String?
    let bundleIdData: NSData?
    let appVersion: String?
    let opaqueValue: NSData?
    let sha1Hash: NSData?
    let inAppPurchaseReceipts: [ParsedInAppPurchaseReceipt]?
    let originalAppVersion: String?
    let receiptCreationDate: Date?
    let expirationDate: Date?
}

struct ParsedInAppPurchaseReceipt {
    let quantity: Int?
    let productIdentifier: String?
    let transactionIdentifier: String?
    let originalTransactionIdentifier: String?
    let purchaseDate: Date?
    let originalPurchaseDate: Date?
    let subscriptionExpirationDate: Date?
    let cancellationDate: Date?
    let webOrderLineItemId: Int?
}</pre>

<p>You may be wondering, &#8220;How'd he know what values are encoded within the extracted receipt payload?&#8221;. Apple has a very handy <a href="https://developer.apple.com/library/content/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html">list of all the values that are encoded</a>, so I listed each property out in my struct according to their documentation.</p>

<p>Parsing the receipt produces the most valuable piece of the whole process. Sure, it's necessary to go through all of the other validation steps, but having a <strong>decoded receipt</strong> with actual <strong>human-readable values</strong> is, to me, a huge step.</p>

<p>Full disclaimer though: parsing the receipt is not very&#8230; Swifty.</p>

<p>We're going to be working with all kinds of ugly things like <code>UnsafeMutablePointers</code>, and cryptically-named C Types.</p>

<p>Let's take it one step at a time though&#8230;</p>

<p><a name="visualizing-receipt-structure" class="jump-target"></a></p>

<h1 id="visualizing-the-encoded-receipt-8217-s-structure">Visualizing the encoded receipt's structure</h1>

<p>Up to now, we've been working only with the PKCS #7 <em>container</em> for the receipt. Now it's time to dig into the container and see what it actually <em>contains</em>.</p>

<p>If you crack open the container, what you find is a long series of bytes that encode the actual structure of the receipt.</p>

<p>From beginning to end, the bytes <em>should</em> encode what's called an &#8220;ASN.1 Set&#8221;. In fact, if you open the PKCS #7 container and it <em>doesn't</em> encode an ASN.1 Set, that'd warrant a receipt validation failure&#8230;<a href="#handling-error-conditions">more about handling that in a minute</a>.</p>

<p>Here's a visual representation of an ASN.1 Set:<br />
<a href="https://www.andrewcbancroft.com/wp-content/uploads/2017/07/ASN1Set.jpeg"><img src="https://www.andrewcbancroft.com/wp-content/uploads/2017/07/ASN1Set.jpeg" alt="ASN.1 Set" width="923" height="338" class="alignnone size-full wp-image-13513" srcset="https://www.andrewcbancroft.com/wp-content/uploads/2017/07/ASN1Set.jpeg 923w, https://www.andrewcbancroft.com/wp-content/uploads/2017/07/ASN1Set-300x110.jpeg 300w, https://www.andrewcbancroft.com/wp-content/uploads/2017/07/ASN1Set-768x281.jpeg 768w" sizes="(max-width: 923px) 100vw, 923px" /></a></p>

<p>Since we've just got a bunch of bytes encoding things, there's got to be some way to say, &#8220;This byte, or these series of bytes, represent [this human understandable thing]&#8221;.</p>

<p>That's exactly what we've got, as you can see by the visual representation.</p>

<p>The first byte in the receipt payload (the green box in the visualization) signals that the bytes that follow encode an ASN.1 Set.</p>

<p>The next bytes in the series (the blue box) encode how long the ASN.1 Set is, so that as you're going along parsing and decoding the contents of the Set, you know when to stop.</p>

<p>The final series of bytes (the yellow boxes) encode chunks of information that can be decoded to give you human readable receipt attributes. Those chunks, themselves, are encoded as ASN.1 <em>Sequences</em>.</p>

<p>So what does an ASN.1 Sequence look like? Here's a visual:</p>

<p><a href="https://www.andrewcbancroft.com/wp-content/uploads/2017/07/ASN1Sequence.jpeg"><img src="https://www.andrewcbancroft.com/wp-content/uploads/2017/07/ASN1Sequence.jpeg" alt="ASN.1 Sequence" width="919" height="337" class="alignnone size-full wp-image-13514" srcset="https://www.andrewcbancroft.com/wp-content/uploads/2017/07/ASN1Sequence.jpeg 919w, https://www.andrewcbancroft.com/wp-content/uploads/2017/07/ASN1Sequence-300x110.jpeg 300w, https://www.andrewcbancroft.com/wp-content/uploads/2017/07/ASN1Sequence-768x282.jpeg 768w" sizes="(max-width: 919px) 100vw, 919px" /></a></p>

<p>When it comes to app receipts, ASN.1 <em>Sequences</em> are used to say, &#8220;Hey, this series of bytes encodes [the bundle identifier] or [the original app version] or [some other receipt attribute].&#8221;</p>

<p>Each ASN.1 Sequence has a flag (the pink box in the visualization) to signal that the bytes that follow do, in fact, encode an ASN.1 Sequence.</p>

<p>Then, just like an ASN.1 Set, the next bytes in line (the blue box) encode how long the Sequence is. Then comes what we're really after in all this Set/Sequence talk:</p>

<p>The <em>type</em> of attribute (bundle identifier, for example) is encoded next in the series of bytes as an ASN.1 Integer (note that this isn't a Swift Int&#8230;yet&#8230;we'll decode it soon). Each attribute type has a unique ASN.1 Integer value, kind of like an ID. <a href="https://developer.apple.com/library/content/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html">Apple's documentation</a> is helpful in figuring out which ASN.1 Integer value maps to which receipt attribute.</p>

<p>After the attribute type comes some bytes that encode an &#8220;attribute version&#8221;, also as an ASN.1 Integer. At the time of this guide's publication, &#8220;attribute version&#8221; isn't used for anything. Nonetheless, the series of bytes right after the attribute type within the ASN.1 Sequence is reserved and will always represent the &#8220;attribute version&#8221;.</p>

<p>The remaining bytes in the ASN.1 Sequence encode the actual <em>value</em> of the attribute as an ASN.1 Octet String (don't let the word &#8220;Octet String&#8221; trick you into thinking that it's actually a String&#8230; they're <em>bytes</em> that we'll have to decode shortly&#8230;)</p>

<p>Knowing how the receipt payload is structured will help us formulate a strategy around parsing it. Let's imagine a simple algorithm to do it now.</p>

<p><a name="parsing-strategy" class="jump-target"></a></p>

<h1 id="receipt-parsing-strategy">Receipt parsing strategy</h1>

<p>Let's take it step by step. What if we approach parsing the receipt like this:</p>

<p><strong>1)</strong> Do some preliminary checks to ensure that the receipt payload is in the correct structural format (it should be an ASN.1 Set, for example).</p>

<p><strong>2)</strong> For each ASN.1 Sequence within the ASN.1 Set, check to see what type of attribute it is.</p>

<p><strong>3)</strong> Decode its Octet String value into actual, human-readable values. The decoded values would be represented by Swift Types (Int, String, Date are sufficient to cover all of the possibilities for receipts). The final decoded value depends on what <em>type</em> of attribute it is.</p>

<p><strong>4)</strong> Create and return a ParsedReceipt instance as the final product.</p>

<p>If at any point the receipt payload fails to live up to the expected structure, receipt validation will fail, and we can signal that by throwing an error.</p>

<p><a name="note-on-iap-receipts" class="jump-target"></a></p>

<h2 id="a-note-on-in-app-purchase-receipts">A note on in-app purchase receipts</h2>

<p>As we follow the receipt parsing strategy steps that I just described, there's going to come a point where we run into the ASN.1 Sequence that encodes the in-app purchase receipts.</p>

<p>These are special.</p>

<p>In-app purchase receipts are encoded as ASN.1 Sets (with ASN.1 Sequences within) <em>inside</em> the primary ASN.1 Set receipt payload. In other words, they're <em>nested</em> ASN.1 Sets within the <em>overall</em> ASN.1 Set that encodes the whole receipt. The nested Set contains the <em>in-app purchase</em> receipt attributes.</p>

<p>So in order to decode these, we'll have to apply the receipt parsing strategy <em>within</em> the receipt parsing strategy. Fun, huh? We'll only have to do it for the in-app purchase receipt attributes though.</p>

<p><a name="helper-functions" class="jump-target"></a></p>

<h1 id="preparation-step-helper-decoding-functions">Preparation step: Helper decoding functions</h1>

<p>If you saw the <code>ParsedReceipt</code> struct that I proposed earlier in the guide, you'll notice that there are essentially four Swift Types that the receipt attributes (and in-app purchase receipt attributes) get decoded into:</p>

<ul>
<li><code>Int?</code></li>
<li><code>String?</code></li>
<li><code>NSData?</code></li>
<li><code>Date?</code></li>
</ul>

<p><code>NSData</code> has a constructor that can work with <code>UnsafeRawPointers</code> directly, but <code>Int?</code>, <code>String?</code>, and <code>Date?</code> need some help converting from the ASN.1 versions of those Types to the <em>Swift</em> versions of those Types.</p>

<p>Let me put the code before you and follow up with what I'm doing here:</p>

<pre class="lang:swift decode:true " title="Decoding Helpers" >func DecodeASN1Integer(startOfInt intPointer: inout UnsafePointer&lt;UInt8>?, length: Int) -> Int? {
    // These will be set by ASN1_get_object
    var type = Int32(0)
    var xclass = Int32(0)
    var intLength = 0
    
    ASN1_get_object(&intPointer, &intLength, &type, &xclass, length)
    
    guard type == V_ASN1_INTEGER else {
        return nil
    }
    
    let integer = c2i_ASN1_INTEGER(nil, &intPointer, intLength)
    let result = ASN1_INTEGER_get(integer)
    ASN1_INTEGER_free(integer)
    
    return result
}

func DecodeASN1String(startOfString stringPointer: inout UnsafePointer&lt;UInt8>?, length: Int) -> String? {
    // These will be set by ASN1_get_object
    var type = Int32(0)
    var xclass = Int32(0)
    var stringLength = 0

    ASN1_get_object(&stringPointer, &stringLength, &type, &xclass, length)
    
    if type == V_ASN1_UTF8STRING {
        let mutableStringPointer = UnsafeMutableRawPointer(mutating: stringPointer!)
        return String(bytesNoCopy: mutableStringPointer, length: stringLength, encoding: String.Encoding.utf8, freeWhenDone: false)
    }
    
    if type == V_ASN1_IA5STRING {
        let mutableStringPointer = UnsafeMutableRawPointer(mutating: stringPointer!)
        return String(bytesNoCopy: mutableStringPointer, length: stringLength, encoding: String.Encoding.ascii, freeWhenDone: false)
    }
    
    return nil
}

func DecodeASN1Date(startOfDate datePointer: inout UnsafePointer&lt;UInt8>?, length: Int) -> Date? {
    // Date formatter code from https://www.objc.io/issues/17-security/receipt-validation/#parsing-the-receipt
    let dateFormatter = DateFormatter()
    dateFormatter.locale = Locale(identifier: "en_US_POSIX")
    dateFormatter.dateFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'Z'"
    dateFormatter.timeZone = TimeZone(secondsFromGMT: 0)
    
    if let dateString = DecodeASN1String(startOfString: &datePointer, length:length) {
        return dateFormatter.date(from: dateString)
    }
    
    return nil
}</pre>

<p>Each of these decoding functions are dealing with the receipt attribute <em>value</em> portion of the ASN.1 Sequence that we're working on at the time. Recall the structure:<br />
<a href="https://www.andrewcbancroft.com/wp-content/uploads/2017/07/ASN1Sequence.jpeg"><img src="https://www.andrewcbancroft.com/wp-content/uploads/2017/07/ASN1Sequence.jpeg" alt="ASN.1 Sequence" width="919" height="337" class="alignnone size-full wp-image-13514" srcset="https://www.andrewcbancroft.com/wp-content/uploads/2017/07/ASN1Sequence.jpeg 919w, https://www.andrewcbancroft.com/wp-content/uploads/2017/07/ASN1Sequence-300x110.jpeg 300w, https://www.andrewcbancroft.com/wp-content/uploads/2017/07/ASN1Sequence-768x282.jpeg 768w" sizes="(max-width: 919px) 100vw, 919px" /></a></p>

<p>So we take in a pointer that's pointing <em>to</em> the start of one of the attribute <em>values</em> (a yellow box). The yellow box's ASN.1 Octet String encodes either an integer, a string, or a date. (Okay, technically I guess you could include NSData, but this doesn't need to be &#8220;decoded&#8221; really. And the in-app purchase receipts will be parsed and decoded into the stated Types as well, so it all boils down to the three I just mentioned&#8230;thus the reason for only three helper functions).</p>

<p>The strategy for the first two functions is basically to take what we're pointing to, and call <code>ASN1_get_object</code>.</p>

<p>This function call gets us enough information to decode the bytes from the start of the object to the end of the object into either an <code>Int?</code> or a <code>String?</code>. If it fails, <code>nil</code> is returned.</p>

<p>Decoding dates simply involves initializing a <code>DateFormatter</code> with the appropriate locale and date format. The datePointer parameter actually points to an encoded <em>string</em>, so the strategy is to use the <code>DecodeASN1String</code> function we made, and pass the date string to the date formatter.</p>

<p>So long as the string can be decoded, the date formatter instance is used to create an actual <code>Date?</code> instance and return it. Otherwise, <code>nil</code> is returned.</p>

<p><a name="handling-error-conditions" class="jump-target"></a></p>

<h1 id="handling-error-conditions">Handling error conditions</h1>

<p>The kinds of errors that can occur when parsing the receipt payload all have to do with unexpected structure.</p>

<p>For example, if we're expecting to be stepping through an ASN.1 Payload or an ASN.1 Sequence but instead find that it's not what we expect, this is a situation where reeipt validation should fail, because there's no way to decode the receipt attributes if the bytes of the payload don't conform to the expected structure.</p>

<p>In situations where the receipt payload or one of its in-app purchase receipt payloads is &#8220;malformed&#8221; in some way, we can throw an <code>Error</code>.</p>

<p>I've highlighted two new <code>ReceiptValidationError</code> cases here:</p>

<pre class="lang:swift decode:true mark:7-8" title="New ReceiptValidationError cases" >enum ReceiptValidationError : Error {
    case couldNotFindReceipt
    case emptyReceiptContents
    case receiptNotSigned
    case appleRootCertificateNotFound
    case receiptSignatureInvalid
    case malformedReceipt
    case malformedInAppPurchaseReceipt
}
</pre>

<p><a name="implementing-receipt-parser" class="jump-target"></a></p>

<h1 id="implenting-receiptparser">Implenting ReceiptParser</h1>

<p>OK! We've got a few helper functions to decode the receipt attributes, and we've got some <code>ReceiptValidationError</code> cases to throw in case parsing fails.</p>

<p>At a very high level, the ReceiptParser will take the following skeletal structure:</p>

<pre class="lang:swift decode:true" title="ReceiptParser Skeleton" >struct ReceiptParser {
    func parse(_ PKCS7Container: UnsafeMutablePointer&lt;PKCS7>) throws -> ParsedReceipt {
        var bundleIdentifier: String?
        var bundleIdData: NSData?
        var appVersion: String?
        var opaqueValue: NSData?
        var sha1Hash: NSData?
        var inAppPurchaseReceipts = [ParsedInAppPurchaseReceipt]()
        var originalAppVersion: String?
        var receiptCreationDate: Date?
        var expirationDate: Date?
        
        // Parse the receipt, setting each variable
        
        return ParsedReceipt(bundleIdentifier: bundleIdentifier,
                             bundleIdData: bundleIdData,
                             appVersion: appVersion,
                             opaqueValue: opaqueValue,
                             sha1Hash: sha1Hash,
                             inAppPurchaseReceipts: inAppPurchaseReceipts,
                             originalAppVersion: originalAppVersion,
                             receiptCreationDate: receiptCreationDate,
                             expirationDate: expirationDate)
    }
    
    func parseInAppPurchaseReceipt(currentInAppPurchaseASN1PayloadLocation: inout UnsafePointer&lt;UInt8>?, payloadLength: Int) throws -> ParsedInAppPurchaseReceipt {
        var quantity: Int?
        var productIdentifier: String?
        var transactionIdentifier: String?
        var originalTransactionIdentifier: String?
        var purchaseDate: Date?
        var originalPurchaseDate: Date?
        var subscriptionExpirationDate: Date?
        var cancellationDate: Date?
        var webOrderLineItemId: Int?
        
        // Parse the in-app purchase receipt, setting each variable
        
        return ParsedInAppPurchaseReceipt(quantity: quantity,
                                          productIdentifier: productIdentifier,
                                          transactionIdentifier: transactionIdentifier,
                                          originalTransactionIdentifier: originalTransactionIdentifier,
                                          purchaseDate: purchaseDate,
                                          originalPurchaseDate: originalPurchaseDate,
                                          subscriptionExpirationDate: subscriptionExpirationDate,
                                          cancellationDate: cancellationDate,
                                          webOrderLineItemId: webOrderLineItemId)
    }
</pre>

<p>So a total of two functions: one to parse the overall receipt, and one to parse each in-app purchase receipt nested <em>within</em> the overall receipt.</p>

<p>Now comes the hard part. Actually doing all the decoding. Don't forget the <a href="#parsing-strategy">strategy</a> we're going to take! That'll help you walk through this code without getting insanely overwhelmed (hopefully).</p>

<p><a name="parse-function-implementation" class="jump-target"></a></p>

<h2 id="parse-function-implementation"><code>parse</code> function implementation</h2>

<p>First, the implementation of <code>parse(_:)</code> with comments throughout to help you find where each step of the <a href="#parsing-strategy">strategy</a> is being implemented:</p>

<pre class="lang:swift decode:true" title="Implementation of parse function" >func parse(_ PKCS7Container: UnsafeMutablePointer&lt;PKCS7>) throws -> ParsedReceipt {
    var bundleIdentifier: String?
    var bundleIdData: NSData?
    var appVersion: String?
    var opaqueValue: NSData?
    var sha1Hash: NSData?
    var inAppPurchaseReceipts = [ParsedInAppPurchaseReceipt]()
    var originalAppVersion: String?
    var receiptCreationDate: Date?
    var expirationDate: Date?
    
    // Strategy Step 1: Preliminary structure checks

    // Must have data to work with
    guard let contents = PKCS7Container.pointee.d.sign.pointee.contents, let octets = contents.pointee.d.data else {
        throw ReceiptValidationError.malformedReceipt
    }
    
    // Determine the start and end of the receipt payload
    var currentASN1PayloadLocation = UnsafePointer(octets.pointee.data)
    let endOfPayload = currentASN1PayloadLocation!.advanced(by: Int(octets.pointee.length))
    
    var type = Int32(0)
    var xclass = Int32(0)
    var length = 0
    
    ASN1_get_object(&currentASN1PayloadLocation, &length, &type, &xclass,Int(octets.pointee.length))
    
    // Payload must be an ASN1 Set
    guard type == V_ASN1_SET else {
        throw ReceiptValidationError.malformedReceipt
    }
    
    // Decode Payload
    // Strategy Step 2: Walk through payload (ASN1 Set) and parse each ASN1 Sequence 
    // within (ASN1 Sets contain one or more ASN1 Sequences)
    while currentASN1PayloadLocation! &lt; endOfPayload {
        
        // Get next ASN1 Sequence
        ASN1_get_object(&#038;currentASN1PayloadLocation, &#038;length, &#038;type, &#038;xclass, currentASN1PayloadLocation!.distance(to: endOfPayload))
        
        // ASN1 Object type must be an ASN1 Sequence
        guard type == V_ASN1_SEQUENCE else {
            throw ReceiptValidationError.malformedReceipt
        }
        
        // Attribute type of ASN1 Sequence must be an Integer
        guard let attributeType = DecodeASN1Integer(startOfInt: &#038;currentASN1PayloadLocation, length: currentASN1PayloadLocation!.distance(to: endOfPayload)) else {
            throw ReceiptValidationError.malformedReceipt
        }
        
        // Attribute version of ASN1 Sequence must be an Integer
        guard DecodeASN1Integer(startOfInt: &#038;currentASN1PayloadLocation, length: currentASN1PayloadLocation!.distance(to: endOfPayload)) != nil else {
            throw ReceiptValidationError.malformedReceipt
        }
        
        // Get ASN1 Sequence value
        ASN1_get_object(&#038;currentASN1PayloadLocation, &#038;length, &#038;type, &#038;xclass, currentASN1PayloadLocation!.distance(to: endOfPayload))
        
        // ASN1 Sequence value must be an ASN1 Octet String
        guard type == V_ASN1_OCTET_STRING else {
            throw ReceiptValidationError.malformedReceipt
        }
        
        // Strategy Step 3: Decode attributes
        switch attributeType {
        case 2:
            var startOfBundleId = currentASN1PayloadLocation
            bundleIdData = NSData(bytes: startOfBundleId, length: length)
            bundleIdentifier = DecodeASN1String(startOfString: &#038;startOfBundleId, length: length)
        case 3:
            var startOfAppVersion = currentASN1PayloadLocation
            appVersion = DecodeASN1String(startOfString: &#038;startOfAppVersion, length: length)
        case 4:
            let startOfOpaqueValue = currentASN1PayloadLocation
            opaqueValue = NSData(bytes: startOfOpaqueValue, length: length)
        case 5:
            let startOfSha1Hash = currentASN1PayloadLocation
            sha1Hash = NSData(bytes: startOfSha1Hash, length: length)
        case 17:
            var startOfInAppPurchaseReceipt = currentASN1PayloadLocation
            let iapReceipt = try parseInAppPurchaseReceipt(currentInAppPurchaseASN1PayloadLocation: &#038;startOfInAppPurchaseReceipt, payloadLength: length)
            inAppPurchaseReceipts.append(iapReceipt)
        case 12:
            var startOfReceiptCreationDate = currentASN1PayloadLocation
            receiptCreationDate = DecodeASN1Date(startOfDate: &#038;startOfReceiptCreationDate, length: length)
        case 19:
            var startOfOriginalAppVersion = currentASN1PayloadLocation
            originalAppVersion = DecodeASN1String(startOfString: &#038;startOfOriginalAppVersion, length: length)
        case 21:
            var startOfExpirationDate = currentASN1PayloadLocation
            expirationDate = DecodeASN1Date(startOfDate: &#038;startOfExpirationDate, length: length)
        default:
            break
        }
        
        currentASN1PayloadLocation = currentASN1PayloadLocation?.advanced(by: length)
    }
    
    // Strategy Step 4: Return ParsedReceipt
    return ParsedReceipt(bundleIdentifier: bundleIdentifier,
                            bundleIdData: bundleIdData,
                            appVersion: appVersion,
                            opaqueValue: opaqueValue,
                            sha1Hash: sha1Hash,
                            inAppPurchaseReceipts: inAppPurchaseReceipts,
                            originalAppVersion: originalAppVersion,
                            receiptCreationDate: receiptCreationDate,
                            expirationDate: expirationDate)
}
</pre>

<p>Aside from the work with pointers and the Open SSL function names, the strategy is pretty straight-forward when you look it from a bird&rsquo;s-eye point of view.</p>

<p>Once again, if you&rsquo;re curious about how I knew to map each <code>case</code> within the <code>switch</code> to the correct receipt attribute, I simply got them from <a href="https://developer.apple.com/library/content/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html">Apple&rsquo;s documentation</a>.</p>

<p><a name="parse-in-app-purchase-receipt-implementation" class="jump-target"></a></p>

<h2 id="parseinapppurchaserectipt-function-implementation"><code>parseInAppPurchaseRectipt</code> function implementation</h2>

<p>Now it&rsquo;s time to see how to parse an in-app purchase receipt payload. Take a look:</p>

<pre class="lang:swift decode:true" title="Implementation of parse function" >func parseInAppPurchaseReceipt(currentInAppPurchaseASN1PayloadLocation: inout UnsafePointer&lt;UInt8>?, payloadLength: Int) throws -> ParsedInAppPurchaseReceipt {
    var quantity: Int?
    var productIdentifier: String?
    var transactionIdentifier: String?
    var originalTransactionIdentifier: String?
    var purchaseDate: Date?
    var originalPurchaseDate: Date?
    var subscriptionExpirationDate: Date?
    var cancellationDate: Date?
    var webOrderLineItemId: Int?
    
    // Find the end of the in-app purchase receipt payload
    let endOfPayload = currentInAppPurchaseASN1PayloadLocation!.advanced(by: payloadLength)
    var type = Int32(0)
    var xclass = Int32(0)
    var length = 0
    
    ASN1_get_object(&currentInAppPurchaseASN1PayloadLocation, &length, &type, &xclass, payloadLength)
    
    // Payload must be an ASN1 Set
    guard type == V_ASN1_SET else {
        throw ReceiptValidationError.malformedInAppPurchaseReceipt
    }
    
    // Decode Payload
    // Step through payload (ASN1 Set) and parse each ASN1 Sequence within (ASN1 Sets contain one or more ASN1 Sequences)
    while currentInAppPurchaseASN1PayloadLocation! &lt; endOfPayload {
        
        // Get next ASN1 Sequence
        ASN1_get_object(&#038;currentInAppPurchaseASN1PayloadLocation, &#038;length, &#038;type, &#038;xclass, currentInAppPurchaseASN1PayloadLocation!.distance(to: endOfPayload))
        
        // ASN1 Object type must be an ASN1 Sequence
        guard type == V_ASN1_SEQUENCE else {
            throw ReceiptValidationError.malformedInAppPurchaseReceipt
        }
        
        // Attribute type of ASN1 Sequence must be an Integer
        guard let attributeType = DecodeASN1Integer(startOfInt: &#038;currentInAppPurchaseASN1PayloadLocation, length: currentInAppPurchaseASN1PayloadLocation!.distance(to: endOfPayload)) else {
            throw ReceiptValidationError.malformedInAppPurchaseReceipt
        }
        
        // Attribute version of ASN1 Sequence must be an Integer
        guard DecodeASN1Integer(startOfInt: &#038;currentInAppPurchaseASN1PayloadLocation, length: currentInAppPurchaseASN1PayloadLocation!.distance(to: endOfPayload)) != nil else {
            throw ReceiptValidationError.malformedInAppPurchaseReceipt
        }
        
        // Get ASN1 Sequence value
        ASN1_get_object(&#038;currentInAppPurchaseASN1PayloadLocation, &#038;length, &#038;type, &#038;xclass, currentInAppPurchaseASN1PayloadLocation!.distance(to: endOfPayload))
        
        // ASN1 Sequence value must be an ASN1 Octet String
        guard type == V_ASN1_OCTET_STRING else {
            throw ReceiptValidationError.malformedInAppPurchaseReceipt
        }
        
        // Decode attributes
        switch attributeType {
        case 1701:
            var startOfQuantity = currentInAppPurchaseASN1PayloadLocation
            quantity = DecodeASN1Integer(startOfInt: &#038;startOfQuantity , length: length)
        case 1702:
            var startOfProductIdentifier = currentInAppPurchaseASN1PayloadLocation
            productIdentifier = DecodeASN1String(startOfString: &#038;startOfProductIdentifier, length: length)
        case 1703:
            var startOfTransactionIdentifier = currentInAppPurchaseASN1PayloadLocation
            transactionIdentifier = DecodeASN1String(startOfString: &#038;startOfTransactionIdentifier, length: length)
        case 1705:
            var startOfOriginalTransactionIdentifier = currentInAppPurchaseASN1PayloadLocation
            originalTransactionIdentifier = DecodeASN1String(startOfString: &#038;startOfOriginalTransactionIdentifier, length: length)
        case 1704:
            var startOfPurchaseDate = currentInAppPurchaseASN1PayloadLocation
            purchaseDate = DecodeASN1Date(startOfDate: &#038;startOfPurchaseDate, length: length)
        case 1706:
            var startOfOriginalPurchaseDate = currentInAppPurchaseASN1PayloadLocation
            originalPurchaseDate = DecodeASN1Date(startOfDate: &#038;startOfOriginalPurchaseDate, length: length)
        case 1708:
            var startOfSubscriptionExpirationDate = currentInAppPurchaseASN1PayloadLocation
            subscriptionExpirationDate = DecodeASN1Date(startOfDate: &#038;startOfSubscriptionExpirationDate, length: length)
        case 1712:
            var startOfCancellationDate = currentInAppPurchaseASN1PayloadLocation
            cancellationDate = DecodeASN1Date(startOfDate: &#038;startOfCancellationDate, length: length)
        case 1711:
            var startOfWebOrderLineItemId = currentInAppPurchaseASN1PayloadLocation
            webOrderLineItemId = DecodeASN1Integer(startOfInt: &#038;startOfWebOrderLineItemId, length: length)
        default:
            break
        }
        
        currentInAppPurchaseASN1PayloadLocation = currentInAppPurchaseASN1PayloadLocation!.advanced(by: length)
    }
    
    return ParsedInAppPurchaseReceipt(quantity: quantity,
                                        productIdentifier: productIdentifier,
                                        transactionIdentifier: transactionIdentifier,
                                        originalTransactionIdentifier: originalTransactionIdentifier,
                                        purchaseDate: purchaseDate,
                                        originalPurchaseDate: originalPurchaseDate,
                                        subscriptionExpirationDate: subscriptionExpirationDate,
                                        cancellationDate: cancellationDate,
                                        webOrderLineItemId: webOrderLineItemId)
}
</pre>

<p>As you can see, parsing an in-app purchase receipt uses the same strategy as parsing the overall receipt does.</p>

<p>A receipt may contain zero or more in-app purchase receipts, so this function may get called zero, one, or many times, depending on what your app offers as in-app purchases, and of course, what your users have actually purchased.</p>

<p><a name="final-receipt-parser" class="jump-target"></a></p>

<h1 id="final-receiptparser">Final <code>ReceiptParser</code></h1>

<p>I realize that breaking the code apart like I&rsquo;ve done is good for teaching purposes, but perhaps not so much for &ldquo;I just wanna copy-paste and <em>use</em> this&rdquo; purposes.</p>

<p>I&rsquo;ll spare you having to scroll through <em>all</em> that code again. If you&rsquo;d like to see the full <code>ReceiptParser</code>, <a href="https://github.com/andrewcbancroft/SwiftyLocalReceiptValidator">check out the Swifty Local Receipt Validator repo on GitHub</a>.</p>

<p><a name="using-receipt-parser" class="jump-target"></a></p>

<h1 id="using-receiptparser">Using <code>ReceiptParser</code></h1>

<p>I initialize an instance of <code>ReceiptParser</code> in my <a href="https://www.andrewcbancroft.com/2015/10/13/loading-a-receipt-for-validation-with-swift/#receipt-validator"><code>ReceiptValidator</code> struct</a>, and then call the <code>parse(_:)</code> function from <code>validateReceipt()</code>:</p>

<pre class="lang:swift decode:true mark:2,10,20" title="ReceiptValidator Updates" >enum ReceiptValidationResult {
    case success(ParsedReceipt) // Now has ParsedReceipt for an associated value
    case error(ReceiptValidationError)
}

struct ReceiptValidator {
    let receiptLoader = ReceiptLoader()
    let receiptExtractor = ReceiptExtractor()
    let receiptSignatureValidator = ReceiptSignatureValidator()
    let receiptParser = ReceiptParser()
    
    func validateReceipt() -> ReceiptValidationResult {
        do {
            let receiptData = try receiptLoader.loadReceipt()
            let receiptContainer = try receiptExtractor.extractPKCS7Container(receiptData)
            
            try receiptSignatureValidator.checkSignaturePresence(receiptContainer)
            try receiptSignatureValidator.checkSignatureAuthenticity(receiptContainer)
            
            let parsedReceipt = try receiptParser.parse(receiptContainer)
            return .success(parsedReceipt)
        } catch {
            return .error(error as! ReceiptValidationError)
        }
    }
}
</pre>

<p><a name="preparing-to-finish-receipt-validation" class="jump-target"></a></p>

<h1 id="preparing-to-finish-receipt-validation">Preparing to finish receipt validation!</h1>

<p>What a journey this has been! We&rsquo;re <em>almost done</em> with this receipt validation process.</p>

<p>What&rsquo;s left? After this guide, you still need to&hellip;</p>

<ul>
<li><a href="https://www.andrewcbancroft.com/2017/07/31/finalizing-receipt-validation-in-swift-computing-a-guid-hash/">Compute the GUID hash of your app</a> to compare with the hash that&rsquo;s found within the receipt.</li>
<li>You&rsquo;ll also have to inspect the receipt data to perform any app-specific verification steps.</li>
</ul>

<p>We&rsquo;re that much closer now though! See you next time.</p>

<p><a name="related" class="jump-target"></a></p>

<div class="resources">
  <div class="resources-header">
    You might also enjoy...
  </div>
  

<p><ul class="resources-content">
    <li>
      <i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2015/10/05/preparing-to-test-receipt-validation-for-ios/" title="Preparing to Test Receipt Validation for iOS">Preparing to Test Receipt Validation for iOS</a>
    </li>
    <li>
      <i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2015/10/13/loading-a-receipt-for-validation-with-swift/" title="Loading a Receipt for Validation with Swift">Loading a Receipt for Validation with Swift</a>
    </li>
    <li>
      <i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2015/09/21/openssl-for-ios-swift-the-easy-way/" title="OpenSSL for iOS &#038; Swift the Easy Way">OpenSSL for iOS &amp; Swift the Easy Way</a>
    </li>
    <li>
      <i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2016/06/09/extracting-a-pkcs7-container-for-receipt-validation-with-swift/" title="Extracting a PKCS7 Container for Receipt Validation with Swift">Extracting a PKCS7 Container for Receipt Validation with Swift</a>
    </li>
    <li>
      <i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2017/07/16/receipt-validation-verifying-a-receipt-signature-in-swift/" title="Receipt Validation – Verifying a Receipt Signature in Swift">Receipt Validation – Verifying a Receipt Signature in Swift</a>
    </li>
    <li>
      <i class="fa fa-angle-right"></i> <a href="https://www.andrewcbancroft.com/2017/07/31/finalizing-receipt-validation-in-swift-computing-a-guid-hash/" title="Finalizing Receipt Validation in Swift – Computing a GUID Hash">Finalizing Receipt Validation in Swift – Computing a GUID Hash</a>
    </li>
  </ul>
</div></p>

<p><a name="share" class="jump-target"></a></p>


    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "andrewcbancroft" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </article>



            </div>

        </div>
    </div>

    

    <footer class="footer text-center">
        <div class="container">
            <span class="text-muted">This project contains 146 pages and is available on <a href="https://github.com/andrewcbancroft/datadaylife-blog">GitHub</a>. Copyright &copy; Andrew Bancroft, <time datetime="2019">2019</time>.</span>
        </div>
    </footer>

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js" integrity="sha384-vFJXuSJphROIrBnz7yo7oB41mKfc8JzQZiCq4NCceLEaO4IHwicKwpJf9c9IpFgh"
        crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js" integrity="sha384-alpBpkh1PFOepccYVYDB4do5UnbKysX5WZXm3XxPqe5iKTfUKjNkCk9SaVuEZflJ"
        crossorigin="anonymous"></script>

</body>

</html>